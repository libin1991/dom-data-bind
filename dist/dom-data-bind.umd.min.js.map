{"version":3,"sources":["webpack://DomDataBind/webpack/universalModuleDefinition","webpack://DomDataBind/webpack/bootstrap","webpack://DomDataBind/./node_modules/@purtuga/common/src/jsutils/getGlobal.js","webpack://DomDataBind/(webpack)/buildin/global.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/jsutils/objectExtend.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/jsutils/WeakMap.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/jsutils/dataStore.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/jsutils/runtime-aliases.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/jsutils/Iterator.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/jsutils/Set.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/jsutils/queueCallback.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/jsutils/Compose.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/jsutils/nextTick.js","webpack://DomDataBind/./node_modules/@purtuga/observables/src/objectWatchProp.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/jsutils/Map.js","webpack://DomDataBind/./src/utils.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/domutils/domFind.js","webpack://DomDataBind/./src/directives/Directive.js","webpack://DomDataBind/./src/bindings/text-binding.js","webpack://DomDataBind/./src/Template.js","webpack://DomDataBind/./src/render.js","webpack://DomDataBind/./src/DomDataBind.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/domutils/domHasClass.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/domutils/domAddClass.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/domutils/domRemoveClass.js","webpack://DomDataBind/./src/directives/class-directive.js","webpack://DomDataBind/./src/directives/style-directive.js","webpack://DomDataBind/./src/directives/if-directive.js","webpack://DomDataBind/./src/directives/show-directive.js","webpack://DomDataBind/./src/directives/attr-directive.js","webpack://DomDataBind/./src/directives/prop-directive.js","webpack://DomDataBind/./node_modules/@purtuga/common/src/domutils/domAddEventListener.js","webpack://DomDataBind/./src/directives/on-directive.js","webpack://DomDataBind/./node_modules/@purtuga/observables/src/arrayWatch.js","webpack://DomDataBind/./src/directives/each-directive.js","webpack://DomDataBind/./src/directives/html-directive.js","webpack://DomDataBind/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","global","__webpack_exports__","GLOBAL","self","Function","g","this","eval","e","OBJECT_TYPE","_toString","toString","_hasOwnProperty","objectExtend","FakeWeakMap","mergeIntoObj","mergeObjects","response","total","length","deepMerge","shift","WeakMap","counter","Date","now","Math","random","set","entry","writable","undefined","delete","has","dataStore","stash","functionBindCall","functionBind","objectDefineProperty","objectDefineProperties","defineProperties","objectKeys","keys","arr","isArray","Array","arrayIndexOf","forEach","indexOf","arraySplice","splice","consoleLog","console","log","SymbolIterator","error","warn","iterator","HTMLElementPrototype","HTMLElement","doc","document","head","appendChild","insertBefore","hasAttribute","setAttribute","removeAttribute","FakeIterator","values","slice","idx","constructor","next","configurable","done","_","nextIdx","Set","FakeSet","add","item","push","size","clear","entries","cb","thisArg","[object Object]","callbacks","queue","queueCallback","setTimeout","flushQueue","cbList","PRIVATE","COMMON_DESTROY_METHOD_NAME","k","baseMethods","isDestroyed","init","destroy","executeCallbacksNow","destroyCallbacks","callOnDestroyCallback","onDestroy","callback","inst","getInstanceState","getFactory","staticMethods","extend","args","Class","reduce","newProto","obj","thisObjProto","objKey","isInstanceOf","instanceObj","some","protoKey","arguments","getDestroyCallback","instanceState","stateStore","prop","method","Node","Compose","ComposeConstructor","getNewConstructor","reIsNativeCode","nextTick","setImediate","test","Promise","resolved","resolve","fn","then","catch","immediates","processing","processPending","isQueued","queuedCallbacks","OBSERVABLE_IDENTIFIER","DEFAULT_PROP_DEFINITION","TRACKERS","WATCHER_IDENTIFIER","ARRAY_WATCHABLE_PROTO","HAS_ARRAY_WATCHABLE_PROTO","ARRAY_MUTATING_METHODS","isPureObject","NOTIFY_QUEUE","isNotifyQueued","objectWatchProp","setupObjState","props","setupPropState","setupPropInterceptors","setupInterceptors","storeCallback","makeObservable","unWatch","propSetup","dependents","unsetCallbackAsWatcherOf","watchers","deep","setupCallbackStore","store","async","notify","val","parent","propOldDescriptor","getOwnPropertyDescriptor","newVal","priorVal","walk","force","makeArrayWatchable","walkArray","walkObject","pushCallbacksToQueue","execCallback","queueCallbackAndScheduleRun","x","asDependent","setCallbackAsWatcherOf","unsetDependencyTracker","watchersSet","watching","watcherList","arrCurrentProto","__proto__","arrProtoInterceptor","Map","FakeMap","DOCUMENT","FUNCTION","ELEMENT_PROTOTYPE","Element","ARRAY_PROTOTYPE","VALUE_GETTERS","_bind","DOM_DATA_BIND_PROP","UUID","replace","bindCallTo","arrayForEach","arraySlice","getAttribute","removeChild","createComment","createTextNode","createDocFragment","createDocumentFragment","logError","createValueGetter","evalCode","trim","getNodeAttrNames","node","attrNames","attributes","domFind","domEle","selector","querySelectorAll","Directive","render","handler","data","state","deferUpd","update","tracker","stopWatchingAll","handlerState","newValue","setDependencyTracker","_tokenValueGetter","getNodeHandler","_attr","nodeType","NodeHandler","directive","_d","_n","super","TextBinding","tokenText","_tokenText","nodeValue","nodeToRemove","parentNode","DROPS_NODES_ON_CLONE","frag","cloneNode","childNodes","NODE_CONTAINS_MISSES_TEXT_NODES","div","createElement","text","contains","nodeSplitText","Text","splitText","reHasDataToken","RegExp","reTokenMatch","getNodeValue","hasToken","Template","html","directives","_template","innerHTML","_directives","_bindings","getBindingFor","content","cloneWith","importNode","TemplateInstance","applyBindingsToTemplateInstance","setData","ele","bindings","eleToBindings","ignoredChildren","directiveIterator","attrName","attrValue","managesNode","elePlaceholder","manages","getArrayForNodeFromMap","getDirectiveForAttribute","fakeEle","concat","addTextNodes","filter","onlyElementsWithAttributes","findAllNodes","skip","ignoredParent","compareDocumentPosition","child","lastIndex","childTokenMatches","exec","getTextBindingForToken","tokenTextNode","index","fixEmptyTextNode","tokenPlaceholder","processTextNode","directiveBindings","bindingEle","path","walkEle","unshift","Directives","directivesInstances","getNodeAt","Error","map","directiveInstances","directiveSignature","resultArr","hasChildNodes","firstChild","nextSibling","docFrag","_frag","TEMPLATES","DomDataBind","$ele","Factory","isString","_domDataBindNodeHandlers","binding","domHasClass","el","cssClass","classList","domAddClass","classNameList","String","split","className","domRemoveClass","remove","DIRECTIVE","ClassDirective","attr","newClasses","oldClasses","applyCssClassesToNode","StyleDirective","eleStyleList","style","styleProp","renderUpdate","showElement","renderedEle","renderTemplate","_children","insertEle","destroyRenderedEle","IfDirective","_placeholderEle","HIDDEN","ShowDirective","eleDisplayStyle","display","attrRegExp","AttrDirective","_matches","_isProp","directiveAttr","_htmlAttr","matchRegExp","PropDirective","domAddEventListener","event","capture","events","evListeners","evName","addEventListener","removeEventListener","listeners","matchesDirective","str","escapeString","OnDirective","_eventName","handleEvent","domEv","tokenValue","$ev","$data","evListener","arrayWatch","KEY_DIRECTIVE","NOOP","isEmptyList","list","destroyRowElement","_loop","rowKey","_state","bindersByKey","EachDirective","iteratorArgs","listVar","matches","argName","parseDirectiveValue","_iteratorArgs","binders","listIterator","iterateOverList","isFirstRender","usesKey","getKey","newList","destroyChildBinders","_isSoleChild","parentEle","textContent","binder","_destroy","getDataForIteration","dataObj","rowData","newData","attachedEleBinder","newDomElements","getRowBinder","pos","childBinder","positionChildren","rowEleBinder","itemBinder","rowEle","eleParentNode","placeholderEle","childEleBinders","every","childNode","hasDedicatedParent","HtmlDirective","DomDataBindAll","allDirectives","src_DomDataBind","src_render","directives_Directive","each_directive","if_directive","class_directive","style_directive","show_directive","attr_directive","prop_directive","on_directive","html_directive"],"mappings":"8DAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,UAAAH,GACA,iBAAAC,QACAA,QAAA,YAAAD,IAEAD,EAAA,YAAAC,IARA,CASCK,EAAA,WACD,mBCTA,IAAAC,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAP,QAGA,IAAAC,EAAAI,EAAAE,IACAC,EAAAD,EACAE,GAAA,EACAT,YAUA,OANAU,EAAAH,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAQ,GAAA,EAGAR,EAAAD,QA0DA,OArDAM,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAd,EAAAe,EAAAC,GACAV,EAAAW,EAAAjB,EAAAe,IACAG,EAAAC,eAAAnB,EAAAe,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CV,EAAAgB,EAAA,SAAAtB,GACA,oBAAAuB,eAAAC,aACAN,EAAAC,eAAAnB,EAAAuB,OAAAC,aAAwDC,MAAA,WAExDP,EAAAC,eAAAnB,EAAA,cAAiDyB,OAAA,KAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAnB,EAAAmB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,EAAAY,OAAA,MAGA,GAFAxB,EAAAgB,EAAAO,GACAX,EAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAAnB,EAAAQ,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAAhC,GACA,IAAAe,EAAAf,KAAA2B,WACA,WAA2B,OAAA3B,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAK,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,EAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD7B,EAAAgC,EAAA,GAIAhC,IAAAiC,EAAA,mCCjFA,SAAAC,GAAAlC,EAAAQ,EAAA2B,EAAA,sBAAAC,IAAO,MAAMA,OACK,IAEHtC,EAA2BA,OAFxB,IAGHoC,EAA2BA,EAHxB,oBAIHG,KAAyBA,KAC7BC,EAAS,eAATA,oCCPX,IAAIC,EAGJA,EAAK,WACJ,OAAOC,KADH,GAIL,IAECD,EAAIA,GAAKD,EAAS,cAATA,KAA6B,EAAIG,MAAM,QAC/C,MAAOC,GAEc,iBAAX5C,IAAqByC,EAAIzC,GAOrCH,EAAOD,QAAU6C,uCCnBjB,MAAMI,EAAgB,kBAChBC,EAAgBN,EAASjC,KAAKqB,KAAKd,EAAOkB,UAAUe,UACpDC,EAAkBR,EAASjC,KAAKqB,KAAKd,EAAOkB,UAAUC,gBAmD7CgB,ICxCXC,EDwCWD,EAnCR,SAASA,EAAaE,KAAiBC,GAC1C,IAGIhD,EACAuB,EAJA0B,EAAcF,MACdG,EAAcF,EAAaG,OAC3BC,GAAc,EAUlB,IAN4B,kBAAjBL,IACPK,EAAcL,EACdE,EAAcD,EAAaK,YAC3BH,EAAcF,EAAaG,QAG1BnD,EAAI,EAAGA,EAAIkD,EAAOlD,IACnB,GAAKgD,EAAahD,GAIlB,IAAKuB,KAAOyB,EAAahD,GACjB4C,EAAgBI,EAAahD,GAAIuB,KAE7B6B,GACAV,EAAUO,EAAS1B,MAAUkB,GAC7BC,EAAUM,EAAahD,GAAGuB,MAAUkB,EAEpCQ,EAAS1B,GAAOsB,GAAc,EAAMI,EAAS1B,GAAMyB,EAAahD,GAAGuB,IAGnE0B,EAAS1B,GAAOyB,EAAahD,GAAGuB,IAKhD,OAAO0B,GCrCY,oBAAZK,QACP,WACI,IAAI3C,EAAiBD,EAAOC,eACxB4C,EAAUC,EAAKC,MAAQ,IAEvBH,EAAUR,EAAc,WACxBR,KAAK/B,KAAO,QAA0B,IAAhBmD,EAAKC,WAAmB,GAAMJ,IAAY,MAGpED,EAAQ1B,WACJgC,IAAK,SAASrC,EAAKN,GACf,IAAI4C,EAAQtC,EAAIe,KAAK/B,MAKrB,OAJIsD,GAASA,EAAM,KAAOtC,EACtBsC,EAAM,GAAK5C,EAEXN,EAAeY,EAAKe,KAAK/B,MAAOU,OAAQM,EAAKN,GAAQ6C,UAAU,IAC5DxB,MAEXzB,IAAK,SAASU,GACV,IAAIsC,EACJ,OAAQA,EAAQtC,EAAIe,KAAK/B,QAAUsD,EAAM,KAAOtC,EAC5CsC,EAAM,GAAKE,GAGnBC,OAAU,SAASzC,GACf,IAAIsC,EAAQtC,EAAIe,KAAK/B,MACrB,SAAKsD,GAASA,EAAM,KAAOtC,KAC3BsC,EAAM,GAAKA,EAAM,GAAKE,GACf,IAEXE,IAAK,SAAS1C,GACV,IAAIsC,EAAQtC,EAAIe,KAAK/B,MACrB,QAAKsD,GACEA,EAAM,KAAOtC,IAI5B3B,EAAO0D,QAAUA,EApCrB,GAuCAR,EAAcQ,QAIHR,IClCAoB,GAVXC,MAAQ,IAAIb,EAKZhC,OAAQ,WACJ,OAAO,IAAIgC,WCPZ,MAaMc,EAbehC,EAASZ,KAAKrB,KAAKqB,KAAKY,EAASZ,KAa7B6C,CAAajC,EAASjC,KAAKqB,KAAMY,EAASjC,MAI7DmE,EAA2B5D,EAAOC,eAClC4D,EAA2B7D,EAAO8D,iBAClCC,EAA2B/D,EAAOgE,KAsBzCC,KACOC,EAAiBC,EAAMD,QAEvBE,GADiBV,EAAiBO,EAAII,SACrBX,EAAiBO,EAAIK,UACtCC,EAAiBb,EAAiBO,EAAIO,QAItCC,EAAaC,EAAQC,IAMrBC,GALeF,EAAQG,MACTH,EAAQI,KAIL,oBAAuBzE,QAAUA,OAAO0E,SAAW1E,OAAO0E,SAAW,cAI7FC,EAAuBC,YAAY/D,UAC5BgE,EAAMC,EACCD,EAAIE,KAIG1B,EAAiBsB,EAAqBK,aACrC3B,EAAiBsB,EAAqBM,cACtC5B,EAAiBsB,EAAqBO,cACtC7B,EAAiBsB,EAAqBQ,cACnC9B,EAAiBsB,EAAqBS,iBCzE9D,SAASC,EAAa1B,EAAM2B,GAC/B/B,EAAqBhC,KAAM,KAAOrB,OAC9ByD,KAAQA,EAAK4B,MAAM,GACnBD,OAAQA,EAASA,EAAOC,MAAM,GAAK,KACnCC,IAAQ,EACRrD,MAAQwB,EAAKvB,UAKrBoB,EAAuB6B,EAAaxE,WAChC4E,aAAevF,MAAOmF,GACtBK,MACI7F,YAAY,EACZ8F,cAAc,EACdzF,QACI,MAAMgC,GACF0D,KAAMrE,KAAKsE,EAAEL,MAAQjE,KAAKsE,EAAE1D,OAGhC,GAAID,EAAS0D,KAET,OADA1D,EAAShC,MAAQ8C,EACVd,EAGX,MAAM4D,EAAUvE,KAAKsE,EAAEL,MAQvB,OANAtD,EAAShC,MAAQqB,KAAKsE,EAAElC,KAAKmC,GAEzBvE,KAAKsE,EAAEP,SACPpD,EAAShC,OAAUgC,EAAShC,MAAOqB,KAAKsE,EAAEP,OAAOQ,KAG9C5D,MAInBqB,EAAqB8B,EAAaxE,UAAW0D,GAAkBrE,QAAS,OAAOqB,QCnCxE,MAAMwE,EAAM5E,IAAO4E,KAAO5E,IAAO4E,IAAIlF,UAAU0D,GAAkBpD,IAAO4E,IAAMC,EACtED,QAER,SAASC,KAIhBxC,EAAuBwC,EAAQnF,WAC3B4E,aAAevF,MAAO8F,EAASL,cAAc,GAC7CE,GACI/F,MACI,MAAMwF,KAEN,OADA/B,EAAqBhC,KAAM,KAAOrB,MAAOoF,IAClCA,IAGfW,KACI/F,MAAMgG,GAIF,OAHoC,IAAhCnC,EAAaxC,KAAKsE,EAAGK,IACrB3E,KAAKsE,EAAEM,KAAKD,GAET3E,OAGf2B,KACIhD,MAAMgG,GAAQ,OAAuC,IAAhCnC,EAAaxC,KAAKsE,EAAGK,KAE9CE,MACItG,MAAQ,OAAOyB,KAAKsE,EAAEzD,SAE1BiE,OACInG,QAAUqB,KAAKsE,EAAE1B,OAAO,KAE5BlB,QACI/C,MAAMgG,GACF,MAAMV,EAAMzB,EAAaxC,KAAKsE,EAAGK,GACjC,OAAa,IAATV,IACAjE,KAAKsE,EAAE1B,OAAOqB,EAAK,IACZ,KAKnBF,QACIpF,QACI,OAAO,IAAImF,EAAa9D,KAAKsE,KAGrCS,SACIpG,QACI,OAAO,IAAImF,EAAa9D,KAAKsE,EAAGtE,KAAKsE,KAG7C7B,SACI9D,MAAMqG,EAAIC,GACNjF,KAAKsE,EAAE7B,QAAQkC,GAAQK,EAAGL,EAAMA,EAAM3E,MAAOiF,KAGrDC,CAAClC,IACGrE,QACI,OAAOqB,KAAK+D,aCpExB,MAAMoB,EAAY,IAAIX,EACtB,IAAIY,EAmBWC,MATR,SAAuBL,GACtB,mBAAsBA,IACtBG,EAAUT,IAAIM,GAETI,IACDA,EAAQE,EAAWC,EAAY,MAM3C,SAASA,IACL,MAAMC,MAAcL,GAGpB,IAAIH,EACJ,IAHAG,EAAUL,QACVM,EAAQ,KAEAJ,EAAKQ,EAAOzE,SAChBiE,IACAA,EAAK,KC3Bb,MAAMS,EAAU7D,EAAU5C,SACpB0G,GACF,UACA,SACA,OAIJ,SAASvD,EAAW7C,GAChB,IAAIqG,EAAGvD,KACP,IAAKuD,KAAKrG,EACN8C,EAAKwC,KAAKe,GAEd,OAAOvD,EAIX,MAAMwD,GAKFC,aAAa,EAKbC,SASAC,QAAQC,GACJ,GAAIP,EAAQ9D,IAAI3B,MAAO,CACnB,IAAIiG,EAAmBR,EAAQlH,IAAIyB,MACnCyF,EAAQ/D,OAAO1B,MAEXgG,EACAC,EAAiBxD,QAAQyD,GAGzBb,EAAc,IAAMY,EAAiBxD,QAAQyD,IAIjD,kBAAqBlG,KAAK6F,cAC1B7F,KAAK6F,aAAc,IAU3BM,UAAUC,IAoJd,SAA0BC,GACjBZ,EAAQ9D,IAAI0E,IACbZ,EAAQnE,IAAI+E,MAGhB,OAAOZ,EAAQlH,IAAI8H,IAxJfC,CAAiBtG,MAAM4E,KAAKwB,IAQhCG,aACI,GAAIvG,KAAKkE,YACL,OAAOlE,KAAKkE,cAMlBsC,GAOFC,OAAQ,YAAYC,GAChB,IAAIC,gBAAsB3G,QAY1B,OAVAO,EAAaoG,EAAMrH,UAAWoH,EAAKE,OAAO,SAASC,EAAUC,GACzD,GAAIA,EAAK,CACL,MAAMC,EAAgBD,EAAIxH,WAAawH,EACvC3E,EAAW4E,GAActE,QAAQ,SAASuE,GACtCH,EAASG,GAAUD,EAAaC,KAGxC,OAAOH,QAGJF,GAQXM,aAAc,SAASC,GAEnB,QAAKA,IAIY/E,EAAWnC,KAAKV,WAGd6H,KAAK,SAASC,GAC7B,YAAwC,IAA1BF,EAAYE,MAUlCpI,OAAQ,WACJ,OAAO,IAAIgB,QAAQqH,YA0BvBC,mBA6BG,SAA6BC,EAAeC,GAC/C,MAAO,KACCD,GAEAnJ,EAAOgE,KAAKmF,GAAe9E,QAAQ,SAAUgF,GACrCF,EAAcE,KACd/B,EAA2ByB,KAAMO,IAC7B,GACIH,EAAcE,GAAMC,KACR,WAAXA,KAAyBH,EAAcE,aAAiBE,OAGzD,OADAJ,EAAcE,GAAMC,MACb,IAIfH,EAAcE,GAAQhG,KAK9B+F,GAAcA,EAAW7F,KAAO6F,EAAW7F,IAAI4F,IAC/CC,EAAW9F,OAAO6F,MAa9B,SAASrB,EAAuBE,GACxB,mBAAsBA,GACtBA,IAgCR,MAAMwB,EA5BN,WACI,SAASC,KAAsBnB,GAE3B,OAAI1G,MAAQA,KAAKkE,aAAelE,gBAAgBA,KAAKkE,YAC1ClE,KAAK8F,QAAQY,GAIjB,IAAImB,KAAsBnB,GAIrC,OADAmB,EAAmBvI,UAAU4E,YAAc2D,EACpCA,EAgBKC,GAChBvH,EAAaqH,EAAQtI,UAAWsG,GAChCrF,EAAaqH,EAASpB,GAEPoB,QClQf,IAAIG,EAAiB,eAOjBC,EAAY,WACZ,GAA2B,oBAAhBC,aAA+BF,EAAeG,KAAKD,YAAY5H,YACtE,OAAO4H,YAIX,GAAuB,mBAAZE,SAA0BJ,EAAeG,KAAKC,QAAQ9H,YAAa,CAC1E,IAAI+H,EAAWD,QAAQE,UACvB,OAAO,SAA0BC,GAC7BF,EAASG,KAAKD,GAAIE,MAAMtI,GAAK4C,EAAQG,MAAM/C,KAMnD,IAAIuI,KACAC,GAAa,EAajB,OAAO,SAA6BJ,GAChCG,EAAW7D,KAAK0D,GACXI,IACDA,GAAa,EAdrB,SAASC,IACLrD,EAAW,WACPmD,EAAW1H,OAAX0H,GACIA,EAAW5H,OACX8H,IAEAD,GAAa,GAElB,GAOCC,KAjCI,GAsCZC,GAAW,EACf,MAAMC,EAAkB,IAAIrE,IAC5B,IAAI9G,GAAGkB,GACP,MAAM2G,GAAa,KACf,MAAMJ,MAAiB0D,GAGvB,IAFAA,EAAgB/D,QAChB8D,GAAW,EACNlL,GAAI,EAAGkB,GAAIuG,EAAUtE,OAAQnD,GAAIkB,GAAGlB,KACrCyH,EAAUzH,OAWlBsK,EAAS5C,MAAQgB,KACbyC,EAAgBnE,IAAI0B,GACfwC,IACDA,GAAW,EACXZ,EAASzC,OAIFyC,SCpER,MAAMc,GAAwB,qBAE/BC,IAA4B3E,cAAc,EAAM9F,YAAY,GAC5D0K,GAAW,IAAIxE,EACfyE,GAAqB,mBACrBC,GAAwB,kBACxBC,WAAoCD,KACpCE,IACF,MACA,OACA,QACA,SACA,UACA,OACA,WAEEC,GAAevC,GAAOA,GAA+C,oBAAxC1I,EAAOkB,UAAUe,SAASxC,KAAKiJ,GAC5DwC,GAAe,IAAI9E,EACzB,IAAI+E,IAAiB,EA0Dd,SAASC,GAAgB1C,EAAKW,EAAMrB,GAClCU,EAAIgC,KACLW,GAAc3C,GAIdW,IAASX,EAAIgC,IAAuBY,MAAMjC,IAC1CkC,GAAe7C,EAAKW,GACpBmC,GAAsB9C,EAAKW,IAKtBA,GAAQX,EAAIgC,IAAuBY,MAAMjC,GAAMoC,mBACpDD,GAAsB9C,EAAKW,GAG3BA,GAAQrB,EACRU,EAAIgC,IAAuBY,MAAMjC,GAAMqC,cAAc1D,GAE/CqB,IACNsC,GAAejD,GAAK,GAEhBV,GACAU,EAAIgC,IAAuBgB,cAAc1D,IAUjD,MAAM4D,EA8PH,SAAwB5D,EAAU6D,GAEjC7D,IAEI6D,EAAUC,aACVD,EAAUC,WAAWxI,OAAO0E,GAC5B+D,GAAyB/D,EAAU6D,EAAUC,aAEjDD,EAAUG,SAAS1I,OAAO0E,GAC1B+D,GAAyB/D,EAAU6D,EAAUG,YAvQlBlL,KAC3B4H,EACAV,EACCqB,EAAOX,EAAIgC,IAAuBY,MAAMjC,GAAQX,EAAIgC,KAIzD,OADAkB,EAAQjE,QAAUiE,EACXA,EAGJ,SAASP,GAAc3C,GACrBA,EAAIgC,MACL9G,EAAqB8E,EAAKgC,IACtB1E,cAAc,EACd5C,UAAU,EACV6I,MAAM,EACN1L,OACI+K,SACAQ,WAAY,IAAI1F,EAChB4F,SAAU,IAAI5F,EACdsF,cAAeA,MAGvBQ,GAAmBxD,EAAIgC,IAAuBoB,YAAY,GAC1DI,GAAmBxD,EAAIgC,IAAuBsB,UAAU,IAIhE,SAASE,GAAoBC,EAAOC,GAAQ,GACxCD,EAAMC,MAAQA,EACdD,EAAM3B,UAAW,EACjB2B,EAAME,OAASA,GAGnB,SAASd,GAAe7C,EAAKW,GAczB,OAbKX,EAAIgC,IAAuBY,MAAMjC,KAClCX,EAAIgC,IAAuBY,MAAMjC,IAC7BiD,IAAKjJ,EACLyI,WAAY,IAAI1F,EAChB4F,SAAU,IAAI5F,EACdmG,OAAQ7D,EAAIgC,IACZgB,cAAeA,GACfD,mBAAmB,EACnBQ,KAAMvD,EAAIgC,IAAuBuB,MAErCC,GAAmBxD,EAAIgC,IAAuBY,MAAMjC,GAAMyC,YAAY,GACtEI,GAAmBxD,EAAIgC,IAAuBY,MAAMjC,GAAM2C,UAAU,IAEjEtD,EAAIgC,IAAuBY,MAAMjC,GAG5C,SAASmC,GAAsB9C,EAAKW,GAChC,MAAMmD,EACFxM,EAAOyM,yBAAyB/D,EAAKW,IAASsB,GAE7C6B,EAAkBrM,MACnBuI,EAAIgC,IAAuBY,MAAMjC,GAAMiD,IAAM5D,EAAIW,GAG7CX,EAAIgC,IAAuBY,MAAMjC,GAAM4C,MACvCN,GAAejD,EAAIgC,IAAuBY,MAAMjC,GAAMiD,MAI9D1I,EAAqB8E,EAAKW,GACtBrD,aAAcwG,EAAkBxG,eAAgB,EAChD9F,WAAYsM,EAAkBtM,aAAc,EAC5CC,IAAG,KACKyK,GAASnE,MACTmE,GAASvG,QACLqE,EAAIgC,IAAuBY,MAAMjC,GAAMqC,cACvChD,EAAIgC,IAAuBY,MAAMjC,IAIrCmD,EAAkBrM,IACXqM,EAAkBrM,IAAIV,KAAKiJ,GAG/BA,EAAIgC,IAAuBY,MAAMjC,GAAMiD,KAElDpJ,IAAIwJ,GACA,MAAMC,EAAWjE,EAAIW,GAmBrB,OAlBImD,EAAkBtJ,IAClBwJ,EAASF,EAAkBtJ,IAAIzD,KAAKiJ,EAAKgE,GAEzChE,EAAIgC,IAAuBY,MAAMjC,GAAMiD,IAAMI,EAK7ChE,EAAIgC,IAAuBY,MAAMjC,GAAM4C,MACvCN,GAAee,GAGfA,IAAWC,IACXjE,EAAIgC,IAAuBY,MAAMjC,GAAM2C,SAASK,SAChD3D,EAAIgC,IAAuBY,MAAMjC,GAAMyC,WAAWO,SAClD3D,EAAIgC,IAAuBsB,SAASK,UAGjCK,KAIfhE,EAAIgC,IAAuBY,MAAMjC,GAAMoC,mBAAoB,EAGvDe,IAAsB7B,IACtBjC,EAAIgC,IAAuBsB,SAASK,SAkBrC,SAASV,GAAejD,EAAKkE,GAAO,EAAMC,GAAQ,GACrD,OAAK5B,GAAavC,IAASxE,EAAQwE,IAI9BA,EAAIgC,MAEDO,GAAavC,GACb2C,GAAc3C,GAGTxE,EAAQwE,IACboE,GAAmBpE,IAOtBmE,IAASnE,EAAIgC,IAAuBuB,MAGhCW,IACLlE,EAAIgC,IAAuBuB,MAAO,GAGlC/H,EAAQwE,GAWhB,SAAmBzE,EAAK4I,GACpB,IAAK,IAAIvN,EAAE,EAAGkB,EAAEyD,EAAIxB,OAAQnD,EAAEkB,EAAGlB,IAC7BqM,GAAe1H,EAAI3E,IAAI,EAAMuN,GAZ7BE,CAAUrE,GAgBlB,SAAoBA,EAAKmE,GAErB,MAAM7I,EAAOD,EAAW2E,GAExB,IAAK,IAAIpJ,EAAE,EAAGkB,EAAEwD,EAAKvB,OAAQnD,EAAEkB,EAAGlB,IACzBoJ,EAAIgC,IAAuBY,MAAMtH,EAAK1E,MACvCiM,GAAe7C,EAAK1E,EAAK1E,IACzBkM,GAAsB9C,EAAK1E,EAAK1E,KAK/BoJ,EAAIgC,IAAuBY,MAAMtH,EAAK1E,IAAI2M,OAC3CY,IAEAnE,EAAIgC,IAAuBY,MAAMtH,EAAK1E,IAAI2M,MAAO,EAE7ChB,GAAavC,EAAI1E,EAAK1E,MACtBqM,GAAejD,EAAI1E,EAAK1E,KAAK,EAAMuN,IA/B3CG,CAAWtE,GAGRA,QAdP,GAjBWA,EAiEf,SAAS2D,KAGAzK,KAAK6E,OAKL7E,KAAKwK,MAINxK,KAAKyC,QAAQ4I,IAHbrL,KAAKyC,QAAQ6I,IASd,SAAqCtG,GACpCA,GACAqG,GAAqBrG,GAGzB,GAAIuE,KAAmBD,GAAazE,KAChC,OAGJ0E,IAAiB,EACjBvB,GAASzC,IAbTgG,IAgBJ,SAASF,GAAqBjF,GAC1BkD,GAAa5E,IAAI0B,GAGrB,SAASkF,GAAatG,GAClBA,IAGJ,SAASO,KACL,MAAMsD,MAAsBS,IAC5BA,GAAaxE,QACbyE,IAAiB,EACjB,IAAK,IAAIiC,EAAE,EAAG5K,EAAMiI,EAAgBhI,OAAQ2K,EAAE5K,EAAO4K,IACjD3C,EAAgB2C,KAEpB3C,EAAgBhI,OAAS,EAG7B,SAASiJ,GAAc1D,GAEfA,EAASqF,aAAezL,KAAKkK,YAC7BwB,GAAuBtF,EAAUpG,KAAKkK,YACtClK,KAAKkK,WAAWxF,IAAI0B,KAEpBsF,GAAuBtF,EAAUpG,KAAKoK,UACtCpK,KAAKoK,SAAS1F,IAAI0B,IAsCnB,SAASuF,GAAuBvF,GACnC4C,GAAStH,OAAO0E,GAsBpB,SAASsF,GAAuBtF,EAAUwF,GACjCxF,EAAS6C,MACVjH,EAAqBoE,EAAU6C,IAC3B7E,cAAc,EACd5C,UAAU,EACV7C,OACIkN,SAAU,IAAIrH,KAGtBxC,EAAqBoE,EAAU,mBAC3BhC,cAAc,EACd5C,UAAU,EACV7C,QACIyH,EAAS6C,IAAoB4C,SAASpJ,QAAQqJ,GAC1CA,EAAYpK,OAAO0E,IAEvBA,EAAS6C,IAAoB4C,SAAS/G,YAKlDsB,EAAS6C,IAAoB4C,SAASnH,IAAIkH,GAS9C,SAASzB,GAAyB/D,EAAUwF,GACpCxF,EAAS6C,KACT7C,EAAS6C,IAAoB4C,SAASnK,OAAOkK,GAK9C,SAASV,GAAmB7I,GAM/B,GALKA,EAAIyG,KACLW,GAAcpH,GAIdA,EAAI8G,IACJ,OAGJ,MAAM4C,EAAkB1J,EAAI2J,UAG5B,IAAKD,EAAgB7C,IAAwB,CACzC,MAAM+C,EAAsB7N,EAAOY,OAAO+M,GAC1C3C,GAAuB3G,QAAQiF,IAC3B1F,EAAqBiK,EAAqBvE,GACtCtD,cAAc,EACd5C,UAAU,EACV7C,MAAO,YAAmC+H,GAEtC,MAAM/F,EAAWoL,EAAgBrE,GAAQ7J,KAAKmC,QAAS0G,GAGvD,OAFA1G,KAAK8I,IAAuBoB,WAAWO,SACvCzK,KAAK8I,IAAuBsB,SAASK,SAC9B9J,OAMnBqB,EAAqBiK,EAAqB,QACtC7H,cAAc,EACd7F,MAOI,OANIyK,GAASnE,MACTmE,GAASvG,QACLzC,KAAK8I,IAAuBgB,cAC5B9J,KAAK8I,KAGN9I,KAAKa,UAKpBmB,EAAqBiK,EAAqB9C,IACtCxK,OAAO,IAIXqD,EAAqB+J,EAAiB7C,IAClC9E,cAAc,EACd5C,UAAU,EACV7C,MAAOsN,IAIf5J,EAAI2J,UAAYD,EAAgB7C,IC3f7B,MAAMgD,GAAMtM,IAAOsM,KAAOtM,IAAOsM,IAAI5M,UAAU0D,GAAkBpD,IAAOsM,IAAMC,GAG9E,SAASA,MAIhBlK,EAAuBkK,GAAQ7M,WAC3B4E,aAAevF,MAAOwN,GAAS/H,cAAc,GAC7CE,GACI/F,MAKI,OAJAyD,EAAqBhC,KAAM,KAAOrB,OAC9ByD,QACA2B,aAEG/D,KAAKsE,IAGpB/F,KACII,MAAMM,GACF,OAAOe,KAAKsE,EAAEP,OAAOvB,EAAaxC,KAAKsE,EAAElC,KAAMnD,MAGvDqC,KACI3C,MAAMM,EAAKN,GAKP,OAJwC,IAApC6D,EAAaxC,KAAKsE,EAAElC,KAAMnD,KAC1Be,KAAKsE,EAAElC,KAAKwC,KAAK3F,GACjBe,KAAKsE,EAAEP,OAAOa,KAAKjG,IAEhBqB,OAGf2B,KACIhD,MAAMM,GAAO,OAA2C,IAApCuD,EAAaxC,KAAKsE,EAAElC,KAAMnD,KAElD4F,MACItG,MAAQ,OAAOyB,KAAKsE,EAAElC,KAAKvB,SAE/BiE,OACInG,QACIgE,EAAY3C,KAAKsE,EAAElC,KAAM,GACzBO,EAAY3C,KAAKsE,EAAEP,OAAQ,KAGnCrC,QACI/C,MAAMM,GACF,MAAMgF,EAAMzB,EAAaxC,KAAKsE,EAAElC,KAAMnD,GACtC,OAAa,IAATgF,IACAtB,EAAY3C,KAAKsE,EAAElC,KAAM6B,EAAK,GAC9BtB,EAAY3C,KAAKsE,EAAEP,OAAQE,EAAK,IACzB,KAKnB7B,MACIzD,QACI,OAAO,IAAImF,EAAa9D,KAAKsE,EAAElC,QAGvC2B,QACIpF,QACI,OAAO,IAAImF,EAAa9D,KAAKsE,EAAEP,UAGvCgB,SACIpG,QACI,OAAO,IAAImF,EAAa9D,KAAKsE,EAAElC,KAAMpC,KAAKsE,EAAEP,UAGpDtB,SACI9D,MAAMqG,EAAIC,GACNjF,KAAKsE,EAAElC,KAAKK,QAAQ,CAACkC,EAAMjH,IAAMsH,EAAGhF,KAAKsE,EAAEP,OAAOrG,GAAIiH,EAAM3E,MAAOiF,KAG3EC,CAAClC,IACGrE,QACI,OAAOqB,KAAK+E,cCrFxB,MAAMqH,GAAwB7I,EACxB8I,GAAwBvM,EACxBwM,GAAwBC,QAAQjN,UAChCkN,GAAwBjK,EAAMjD,UAC9BmN,GAAwB,IAAIP,GAC5BQ,GAAwBL,GAASnN,KAAKrB,KAAKqB,KAAKmN,GAASnN,MAElDyN,GAAqB,cACrBlH,GAAqB7D,EAAU5C,SAC/B4N,QAA2B1L,EAAKC,SAAWC,EAAKC,SAAShB,SAAS,IAAIwM,QAAQ,cAAe,MAE7FC,GAAqBJ,GAAML,GAASxO,KAAKqB,KAAMmN,GAASxO,MACxDwL,GAAqBlL,GAA2C,oBAAtCC,EAAOkB,UAAUe,SAASxC,KAAKM,GAEzD4O,GAAqBD,GAAWN,GAAgB/J,SAChDuK,GAAqBF,GAAWN,GAAgBxI,OAChDL,GAAqBmJ,GAAWR,GAAkB3I,cAClDsJ,GAAqBH,GAAWR,GAAkBW,cAClDrJ,GAAqBkJ,GAAWR,GAAkB1I,cAClDC,GAAqBiJ,GAAWR,GAAkBzI,iBAClDH,GAAqBoJ,GAAWR,GAAkB5I,cAClDwJ,GAAqBJ,GAAWR,GAAkBY,aAClDC,GAAqBT,GAAMN,GAASe,cAAef,IACnDgB,GAAqBV,GAAMN,GAASgB,eAAgBhB,IACpDiB,GAAqBX,GAAMN,GAASkB,uBAAwBlB,IAC5DmB,GAAqBb,GAAM5J,EAAQG,MAAOH,GAGhD,SAAS0K,GAAkBC,GAG9B,GAFAA,EAAWA,EAASC,OAEhBjB,GAAc9K,IAAI8L,GAClB,OAAOhB,GAAclO,IAAIkP,GAG7B,MAAMnF,EAAK,IAAI+D,GAAS,0FAINoB,qDAIJA,kBAKd,OADAhB,GAAcnL,IAAImM,EAAUnF,GACrBA,EAGJ,SAASqF,GAAiBC,GAC7B,MAAMC,KACAjN,EAAQgN,EAAKE,WAAWjN,OAE9B,IAAI,IAAInD,EAAI,EAAGA,EAAIkD,EAAOlD,IACtBmQ,EAAUjJ,KAAKgJ,EAAKE,WAAWnJ,KAAKjH,GAAGO,MAG3C,OAAO4P,ECjDIE,OAHR,SAAiBC,EAAQC,GAC5B,OAAO1L,EAAMjD,UAAU0E,MAAMnG,KAAKmQ,EAAOE,iBAAiBD,KCyH/CE,qBAjHgBvG,EAU3B1C,aAAsB,MAAO,GAM7BA,iBAAmB,OAAO,EAS1BkJ,OAAOC,EAAST,EAAMU,GAClB,IAAIC,EAAQ9I,GAAQlH,IAAI8P,GAEnBE,IACDA,GACID,KAAY,KACZ3P,MAAY,GACZiK,UAAY,EACZ4F,SAAYxO,KAAKyO,OAAOvP,KAAKc,KAAMqO,GACnCK,QAAY,IAAM1O,KAAKoO,OAAOC,EAAST,EAAMW,EAAMD,OAGvD7I,GAAQnE,IAAI+M,EAASE,IAIrBA,EAAMD,OAASA,IACXC,EAAMG,QAAQC,iBACdJ,EAAMG,QAAQC,kBAElBJ,EAAMD,KAAOA,GAGbC,EAAM3F,WAIV2F,EAAM3F,UAAW,EACjBZ,GAASuG,EAAMC,WASnBC,OAAOJ,GAIH,GAAIA,EAAQxI,YACR,OAGJ,MAAM+I,EAAenJ,GAAQlH,IAAI8P,GAEjC,GAAIO,EAAc,CACd,IAAIC,EAAW,IJ4SpB,SAA8BzI,GACjC4C,GAAStE,IAAI0B,GI3SL0I,CAAqBF,EAAaF,SAElC,IACIG,EAAW7O,KAAK+O,kBAAkBH,EAAaN,UAG3CD,EAAQI,QACRJ,EAAQI,OAAOI,GAGvB,MAAM3O,GACFqN,GAASrN,GAGbyL,GAAuBiD,EAAaF,SAEpCE,EAAahG,UAAW,EACpBgG,EAAajQ,QAAUkQ,IACvBD,EAAajQ,MAAQkQ,IAajCG,eAAepB,GAIX,OAHI5N,KAAKiP,OAA2B,IAAlBrB,EAAKsB,UACnBrL,GAAgB+J,EAAM5N,KAAKiP,OAExB,IAAIE,GAAYnP,KAAM4N,WAU/BuB,WAAoBvH,EACtB9B,KAAKsJ,EAAWxB,GACZ5N,KAAKqP,GAAKD,EACVpP,KAAKsP,GAAK1B,EAKd7H,UACI,MAAMwI,EAAQ9I,GAAQlH,IAAIyB,MACtBuO,IACIA,EAAMG,SAAWH,EAAMG,QAAQC,iBAC/BJ,EAAMG,QAAQC,kBAEdJ,EAAMD,OACNC,EAAMD,KAAO,OAGrBiB,MAAMxJ,UACNN,GAAQ/D,OAAO1B,MAQnBoO,OAAOE,GACHtO,KAAKqP,GAAGjB,OAAOpO,KAAMA,KAAKsP,GAAIhB,GASlCG,OAAOI,GACH,MAAMN,EAAQ9I,GAAQlH,IAAIyB,MAC1B,GAAIuO,GAASA,EAAME,OACf,OAAOF,EAAME,OAAOI,ICpIjBW,qBAxCkBrB,GAC7BrI,KAAK2J,GACDzP,KAAK0P,WAAaD,EAClBzP,KAAK+O,kBAAoBvB,GAAkBiC,GAG/CrB,OAAOC,EAAST,EAAMU,GAClBiB,MAAMnB,OAAOC,EAAST,EAAMU,GAC5B,MAAMC,EAAQ9I,GAAQlH,IAAI8P,GACrBE,EAAME,SACPF,EAAME,OAASI,KACPA,IAAajB,EAAK+B,YAClB/B,EAAK+B,UAAYd,MAajCG,eAAepB,GAIX,GAAsB,IAAlBA,EAAKsB,UAAkBtB,EAAK+B,YAAc/C,GAAM,CAChD,MAAMgD,EAAehC,EAErBA,EAAOA,EAAKiC,WAAWnM,aAAaH,EAAS6J,eAAe,IAAKwC,GACjEA,EAAaC,WAAW3C,YAAY0C,GAGxC,OAAOL,MAAMP,eAAepB,KC3BpC,MACMkC,GAAuB,MACzB,MAAMC,EAAO1C,KAGb,OAFA0C,EAAKtM,YAAY2J,GAAe,SAChC2C,EAAKtM,YAAY2J,GAAe,KACkB,IAA3C2C,EAAKC,WAAU,GAAMC,WAAWpP,QAJd,GAMvBqP,GAAkC,MACpC,MAAMC,EAAM5M,EAAS6M,cAAc,OAC7BC,EAAOjD,GAAe,QAE5B,OADA+C,EAAI1M,YAAY4M,IACRF,EAAIG,SAASD,IAJe,GASlCE,GAAwBzD,GAAW0D,KAAKlR,UAAUmR,WAGlDC,GAAwB,IAAIC,OAnBA,aAoB5BC,GAAwB,IAAID,OApBA,YAoB+B,KAC3DE,GAAwBjD,GAAQA,EAAOA,EAAK+B,UAAY,GACxDmB,GAAwBlD,GAAQ8C,GAAexI,KAAK2I,GAAajD,IAmCxDmD,aA5BX7M,YAAY8M,EAAMC,MACdjR,KAAKkR,UAAY3N,EAAS6M,cAAc,YACxCpQ,KAAKkR,UAAUC,UAAYH,EAC3BhR,KAAKoR,YAAcH,EACnBjR,KAAKqR,UAAYC,GAActR,KAAKkR,UAAUK,QAASN,GAa3DO,UAAUlD,MACNvE,GAAeuE,GACf,MAAM3N,EAAW4C,EAASkO,WAAWzR,KAAKkR,UAAUK,SAAS,GAM7D,OALA5Q,EAASgM,IAAsB,IAAI+E,GAC/B/Q,EACAgR,GAAgChR,EAAUX,KAAKqR,UAAWrR,KAAKoR,cAEnEzQ,EAASgM,IAAoBiF,QAAQtD,GAC9B3N,IAcR,SAAS2Q,GAAcO,EAAKZ,GAe/B,MAAMa,EAAoB,IAAI5F,IACxB6F,EAAoB,IAAI7F,IACxB8F,EAAoB,IAAIxN,IAC9B,IAAIwJ,EAEJ,MAAMiE,EAAoB9D,IACtB,IAAI+D,EACAC,EACAC,EACAC,EAAiBrE,EAErB,KAAQkE,EAAW/D,EAAUxM,IAAIqM,IAc7B,GAbAmE,EAAYlF,GAAae,EAAQkE,IACjCE,EAAcjE,EAAUmE,aAGpBD,EAAiBlF,GAAc,KAGnCoF,GAAuBR,EAAeM,GAAgBzN,KAClD4N,GAAyBrE,EAAW+D,EAAUC,IAGlDtO,GAAgBmK,EAAQkE,GAEpBE,EAAa,CACbJ,EAAgBtN,IAAIsJ,GAKpBA,EAAO6B,WAAWnM,aAAa2O,EAAgBrE,GAC/C,MAAMyE,EAAUlP,EAAS6M,cAAc,OACvCqC,EAAQhP,YAAYuK,GACpBqE,EAAe/D,KAAOmE,EAAQtB,UAGtC,OAAOiB,GA8GX,OAiJJ,SAAsBP,GAClB,OAAQA,GACHa,OAAO3E,GAAQ8D,EAAK,MACpBjL,OAAO+L,OACPC,OAAOC,IAjNZC,CAAajB,GAAKpP,QAAQmL,IACtB,IAAImF,GAAO,EAEX,GAAIf,EAAgBnN,KAChB,IAAK,IAAImO,KAAiBhB,EAAgBjO,SAUtC,GATImM,IAAqD,IAAlBtC,EAAKsB,SACU,GAA9C8D,EAAcC,wBAAwBrF,KACtCmF,GAAO,GAGNC,EAAc1C,SAAS1C,KAC5BmF,GAAO,GAGPA,EACA,MAKZ/E,EAASJ,EAEJmF,IAEqB,IAAlBnF,EAAKsB,SACL+B,EAAW9J,KAAK8K,GAGO,IAAlBrE,EAAKsB,UA3EEgE,KACpB,GAAIpC,GAASoC,GAAQ,CACjBtC,GAAauC,UAAY,EACzB,IAAIxD,EAAYkB,GAAaqC,GACzBE,EAAoBxC,GAAayC,KAAK1D,GAE1C,KAAOyD,GAEH,GAAIzD,IAAc,KAAOyD,EAAkB,GAAK,KAC5Cb,GAAuBR,EAAemB,GAAOtO,KAAK0O,GAAuB9D,GAAa4D,EAAkB,KACxGA,EAAoB,SAEnB,CACD,IAAIG,EAAgBhD,GAAc2C,EAAOE,EAAkBI,OAIvD1D,IACA2D,GAAiBP,GAUrBA,EAAQ3C,GAAcgD,EAAeH,EAAkB,GAAGvS,QAC1D,MAAM6S,EAAmBH,EAAc1D,WAAWnM,aAAayJ,GAAcP,IAAO2G,GACpFA,EAAc1D,WAAW3C,YAAYqG,GAErChB,GAAuBR,EAAe2B,GAAkB9O,KAAK0O,GAAuB9D,GAAa4D,EAAkB,KAInHxC,GAAauC,UAAY,IACzBC,EAAoBxC,GAAayC,KAAKxC,GAAaqC,MAEzBpD,IACtB2D,GAAiBP,MAoCzBS,CAAgB/F,MAK5BI,EAAS,KAIT+D,EAActP,QAAQ,CAACmR,EAAmBC,KACtC,GAAIhC,IAAQgC,EAER,YADA/B,EAASxQ,OAAQsS,GAIrB,MAAME,KACN,IAAIC,EAAUF,EACVlJ,EAAUoJ,EAAQlE,WAEtB,KAAOkE,IAAYlC,GACfiC,EAAKE,QAAQF,EAAKpR,QAAQ7E,KAAK8M,EAAOsF,WAAY8D,IAElDpJ,GADAoJ,EAAUA,EAAQlE,YACAA,WAGtBiC,EAASxQ,IAAIwS,EAAMF,KAGvB7B,EAAcjN,QACdkN,EAAgBlN,QAETgN,EAaJ,SAASH,GAAgC5B,EAAM+B,EAAUmC,GAC5D,MAAMtT,KAcN,OAZAmR,EAASrP,QAAQ,CAACyR,EAAqBJ,KACnC,MAAMlG,EAcd,SAAmB5Q,EAAM8W,GACrB,IAAKA,EAAKjT,OACN,OAAO7D,EAIX,OADA+P,GAAa+G,EAAMN,GAASxW,EAAOA,EAAKiT,WAAWuD,IAC5CxW,EApBUmX,CAAUpE,EAAM+D,GAC7B,GAAKlG,EAKL,IAAK,IAAIlQ,EAAE,EAAGkB,EAAEsV,EAAoBrT,OAAQnD,EAAIkB,EAAGlB,IAC/CiD,EAASiE,KAAKsP,EAAoBxW,GAAGsR,eAAepB,EAAMqG,SAL1D1G,GAAS,IAAI6G,EAAO,mDASrBzT,EAYX,SAAS4R,GAAuB8B,EAAKzG,GAIjC,OAHKyG,EAAI1S,IAAIiM,IACTyG,EAAI/S,IAAIsM,MAELyG,EAAI9V,IAAIqP,GAanB,SAAS0F,GAAuBnF,EAAWsB,GACvCA,EAAYA,EAAU/B,OAEtB,IAAI4G,EAAqB7O,GAAQlH,IAAI4P,GAWrC,OATKmG,IACDA,KACA7O,GAAQnE,IAAI6M,EAAWmG,IAGtBA,EAAmB7E,KACpB6E,EAAmB7E,GAAa,IAAItB,EAAUsB,IAG3C6E,EAAmB7E,GAG9B,SAAS+C,GAA0BrE,EAAW+D,EAAUC,GACpDA,EAAYA,EAAUzE,OAEtB,MAAM6G,KAA2BrC,KAAatF,MAAUuF,IACxD,IAAImC,EAA0B7O,GAAQlH,IAAI4P,GAW1C,OATKmG,IACDA,KACA7O,GAAQnE,IAAI6M,EAAWmG,IAGtBA,EAAmBC,KACpBD,EAAmBC,GAAsB,IAAIpG,EAAU+D,EAAUC,IAG9DmC,EAAmBC,GAS9B,SAAS1B,GAA2BhB,GAChC,OAAwB,IAAjBA,EAAI3C,UAAoC,IAAjB2C,EAAI3C,UAAkB2C,EAAI/D,WAAWjN,OAAS,EAUhF,SAAS8R,GAAa6B,EAAW3C,GAE7B,GADA2C,EAAU5P,KAAKiN,GACXA,EAAI4C,gBAEJ,IADA5C,EAAMA,EAAI6C,WACJ7C,GAAM,CACR,MAAM8C,EAAc9C,EAAI8C,YAGH,IAAjB9C,EAAI3C,UAAoB2C,EAAIlC,WAAae,GAAexI,KAAK2I,GAAagB,KAC1E2C,EAAU5P,KAAKiN,GAGf/B,IACA2D,GAAiB5B,GAGrBA,EAAM8C,EAGd,OAAOH,EAGX,SAASf,GAAiB7F,GACA,IAAlBA,EAAKsB,UAAkBY,KAAyBlC,EAAK+B,YACrD/B,EAAKiC,WAAWnM,aAAayJ,GAAc,IAAKS,GAChDA,EAAKiC,WAAW3C,YAAYU,UAmB9B8D,GACFxN,YAAY0Q,EAAS9C,GACjB9R,KAAK6U,MAAQD,EACb5U,KAAKqR,UAAYS,EAGrB/L,UACI,GAAI/F,KAAKqR,UAAW,CAChB,IAAK,IAAI3T,EAAI,EAAGkB,EAAIoB,KAAKqR,UAAUxQ,OAAQnD,EAAIkB,EAAGlB,IAC9CsC,KAAKqR,UAAU3T,GAAGqI,UAEtB/F,KAAKqR,UAAUxQ,OAAS,GAIhC+Q,QAAQtD,GACJ,IAAK,IAAI5Q,EAAI,EAAGkB,EAAIoB,KAAKqR,UAAUxQ,OAAQnD,EAAIkB,EAAGlB,IAC9CsC,KAAKqR,UAAU3T,GAAG0Q,OAAOE,IC9ZrC,MAAMwG,GAAY,IAAI5I,IAYf,SAASkC,GAAO4C,EAAM1C,EAAM2C,GAI/B,OAHK6D,GAAUnT,IAAIqP,IACf8D,GAAUxT,IAAI0P,EAAM,IAAID,GAASC,EAAMC,IAEpC6D,GAAUvW,IAAIyS,GAAMQ,UAAUlD,GAE1BF,UCIR,MAAM2G,GAAcnN,EAAQnB,QAM/BuO,KAAM,KAENlP,KAAKkL,EAAM1C,GACP,MAAM2G,EAAUjV,KAAKuG,aACfgI,GACFyC,OACA1C,OACA2C,WAAYgE,EAAQhE,WAAWjN,MAAM,IAGzCyB,GAAQnE,IAAItB,KAAMuO,GNxBQ9O,IAAK,iBAAoBA,EM0B/CyV,CAASlE,IACThR,KAAKgV,KAAO5G,GAAO4C,EAAM1C,EAAMC,EAAM0C,YACrC1C,EAAMuD,SAAW9R,KAAKgV,KAAKG,2BAE3BnV,KAAKgV,KAAOhE,EACZzC,EAAMuD,SAAWH,GAAgCX,EAAMM,GAAcN,EAAMzC,EAAM0C,YAAa1C,EAAM0C,YAChG3C,GACAtO,KAAK4R,QAAQtD,IAIrBtO,KAAKmG,UAAU,KACX4G,GAAawB,EAAMuD,SAAUsD,GAAWA,EAAQrP,kBAEzCwI,EAAMD,YACNC,EAAM0C,kBACN1C,EAAMuD,SAEbmD,EAAQ3N,mBAAmBiH,EAAO9I,GAAlCwP,MAURrD,QAAQtD,GACJvE,GAAeuE,GACf,MAAMwD,EAAWrM,GAAQlH,IAAIyB,MAAM8R,SACnC/E,GAAa+E,EAAUsD,GAAWA,EAAQhH,OAAOE,OAG1CyG,UAQfA,GAAY9D,cCrEGoE,OANR,SAAqBC,EAAIC,GAC5B,SAAID,IAAMC,IACCD,EAAGE,UAAUlF,SAASiF,ICGtBE,OANR,SAAqBH,EAAIC,GAC5B,IAAIG,EAAgBC,EAAOJ,GAAU7H,OAAOkI,MAAM,OAAOvB,IAAIwB,GAAaA,EAAUnI,QAChF4H,GAAMI,EAAc7U,QACpB6U,EAAcjT,QAAS8S,GAAaD,EAAGE,UAAU9Q,IAAI6Q,KCD9CO,OAHR,SAAwBR,EAAIC,GAC/B,OAAOD,EAAGE,UAAUO,OAAOR,ICC/B,MAAMS,GAAY,SAsBHC,qBApBqB9H,GAChCjJ,WAAW2M,GACP,OAAOlO,GAAakO,EAAKmE,IAAaA,GAAY,GAItDlQ,KAAKoQ,EAAM/D,GACPnS,KAAKiP,MAAqBiH,EAC1BlW,KAAK+O,kBAAqBvB,GAAmB2E,GAAa,IAG9D/D,OAAOC,EAAST,EAAMU,GAClBiB,MAAMnB,OAAOC,EAAST,EAAMU,GAC5B,MAAMC,EAAQ9I,GAAQlH,IAAI8P,GACrBE,EAAME,SACPF,EAAME,OAASI,KAQ3B,SAA+BjB,EAAMuI,KAAiBC,MAClDhY,EAAOgE,KAAK+T,GACPzD,OAAOtU,EAAOgE,KAAKgU,IACnB3T,QAAQoT,IACDM,EAAWN,KAAeR,GAAYzH,EAAMiI,GAC5CJ,GAAY7H,EAAMiI,IAEZM,EAAWN,IAAcR,GAAYzH,EAAMiI,IACjDC,GAAelI,EAAMiI,MAhBEQ,CAAsBzI,EAAMiB,EAAUA,IAAaN,EAAM5P,MAAQ4P,EAAM5P,cCpB9G,MAAMqX,GAAY,SA6BHM,qBA3BqBnI,GAChCjJ,WAAW2M,GACP,OAAOlO,GAAakO,EAAKmE,IAAaA,GAAY,GAItDlQ,KAAKoQ,EAAM/D,GACPnS,KAAKiP,MAAqBiH,EAC1BlW,KAAK+O,kBAAqBvB,GAAmB2E,GAAa,IAG9D/D,OAAOC,EAAST,EAAMU,GAClBiB,MAAMnB,OAAOC,EAAST,EAAMU,GAC5B,MAAMC,EAAQ9I,GAAQlH,IAAI8P,GAC1B,IAAKE,EAAME,OAAQ,CACf,MAAM8H,EAAgB3I,EAAK4I,MAC3BjI,EAAME,OAAgBI,KAClBzQ,EAAOgE,KAAKyM,GAAUpM,QAAQgU,IACtBF,EAAaE,KAAe5H,EAAS4H,KACrCF,EAAaE,GAAa5H,EAAS4H,WCf3D,MAAMT,GAAY,MAuClB,SAASU,GAAaC,GAEd3W,KAAKrB,QAAUgY,IAIfA,IAAgB3W,KAAK4W,aACrB5W,KAAK4W,YAAcxI,GAAOpO,KAAK6W,eAAgB7W,KAAKsO,KAAMtO,KAAKiR,YAC/DjR,KAAK4W,YAAYE,UAAY9J,GAAWhN,KAAK4W,YAAY3G,WAAY,GACrEvM,GAAa1D,KAAK+W,UAAUlH,WAAY7P,KAAK4W,YAAa5W,KAAK+W,aAEzDJ,GAAe3W,KAAK4W,aAC1B5W,KAAKgX,sBAIb,SAASA,KAEDhX,KAAK4W,cACL5W,KAAK4W,YAAYE,UAAUrU,QAAQvC,GAAKA,EAAE2P,YAAc3P,EAAE2P,WAAW3C,YAAYhN,IACjFF,KAAK4W,YAAYjK,IAAoB5G,UACrC/F,KAAK4W,YAAc,MAIZK,qBA9DkB9I,GAC7BjJ,WAAW2M,GACP,OAAOlO,GAAakO,EAAKmE,IAAaA,GAAY,GAGtD9Q,iBAAmB,OAAO,EAE1BY,KAAKoQ,EAAM/D,GACPnS,KAAKiP,MAAqBiH,EAC1BlW,KAAK+O,kBAAqBvB,GAAmB2E,GAAa,IAG9D/D,OAAOC,EAAST,EAAMU,GAClBiB,MAAMnB,OAAOC,EAAST,EAAMU,GAC5B,MAAMC,EAAQ9I,GAAQlH,IAAI8P,GAErBE,EAAME,SACPF,EAAMqI,YAAwB,KAC9BrI,EAAMwI,UAAwB1I,EAAQ6I,gBACtC3I,EAAM0C,WAAwB5C,EAAQ+C,YACtC7C,EAAMyI,mBAAwBA,GAC9BzI,EAAMsI,eAAwBxI,EAAQiB,GAAGhB,KACzCC,EAAME,OAAwBiI,GAC9BrI,EAAQlI,UAAU,IAAMoI,EAAMyI,uBAItChI,eAAepB,EAAMqD,GACjB,MAAM5C,EAAUkB,MAAMP,eAAepB,GAKrC,OAJAS,EAAQ6I,gBAAkB/J,GAAc,IACxCkB,EAAQ+C,YAAcH,EACtBvN,GAAakK,EAAKiC,WAAYxB,EAAQ6I,gBAAiBtJ,GACvDV,GAAYU,EAAKiC,WAAYjC,GACtBS,ICzCf,MAAM2H,GAAwB,QACxBmB,GAAwB,OA8BfC,qBA5BoBjJ,GAC/BjJ,WAAW2M,GACP,OAAOlO,GAAakO,EAAKmE,IAAaA,GAAY,GAGtDlQ,KAAKoQ,EAAM/D,GACPnS,KAAKiP,MAAqBiH,EAC1BlW,KAAK+O,kBAAqBvB,GAAmB2E,GAAa,IAG9D/D,OAAOC,EAAST,EAAMU,GAClBiB,MAAMnB,OAAOC,EAAST,EAAMU,GAC5B,MAAMC,EAAQ9I,GAAQlH,IAAI8P,GAC1B,IAAKE,EAAME,OAAQ,CACf,MAAM8H,EAAoB3I,EAAK4I,MACzBa,EAAoBzJ,EAAK0J,SAAW,GAC1C/I,EAAME,OAAoBI,KAClBA,EACA0H,EAAae,QAAUD,EAElBd,EAAae,UAAYH,KAC9BZ,EAAae,QAAUH,SCtB3C,MAAMI,GAAa,eA4CJC,qBA1CoBrJ,GAE/BsJ,sBAAwB,OAAOF,GAE/BG,qBAAuB,OAAO,EAE9BxS,WAAW2M,GACP,IAAI8F,EAAgB,GAEpB,OADAhK,GAAiBkE,GAAK1K,KAAK+O,GAAQlW,KAAKyX,SAASvP,KAAKgO,KAAUyB,EAAgBzB,IACzEyB,EAIX7R,KAAKoQ,EAAM/D,GACPnS,KAAKiP,MAAqBiH,EAC1BlW,KAAK+O,kBAAqBvB,GAAmB2E,GAAa,IAC1DnS,KAAK4X,UAAsB,IAAIjH,OAAO3Q,KAAKkE,YAAYuT,UAAWpE,KAAK6C,GAAM,GAGjF9H,OAAOC,EAAST,EAAMU,GAClBiB,MAAMnB,OAAOC,EAAST,EAAMU,GAC5B,IAAIC,EAAQ9I,GAAQlH,IAAI8P,GACnBE,EAAME,SACPF,EAAME,OAASI,KACP7O,KAAKkE,YAAYwT,QACb7I,IAAaN,EAAM5P,QACnBiP,EAAK5N,KAAK4X,WAAa/I,GAIvBA,GAAYN,EAAM5P,QAAUkQ,EAC5BjL,GAAagK,EAAM5N,KAAK4X,UAAW/I,GAE9BN,EAAM5P,QAAUkQ,GACrBhL,GAAgB+J,EAAM5N,KAAK4X,gBC3CnD,MAAMC,GAAc,eAKLC,qBAJoBN,GAC/BC,sBAAwB,OAAOI,GAC/B3S,iBAAmB,OAAO,IC4Cf6S,OA5BR,SAA6BlG,EAAKmG,EAAO5R,EAAU6R,GACtD,IAAIC,EAAcF,EAAMpC,MAAM,OAC1BuC,KAmBJ,OAjBAD,EAAOzV,QAAQ2V,IACXvG,EAAIwG,iBAAiBD,EAAQhS,EAAU6R,GACvCE,EAAYC,IACRrC,OAAQ,IAAMlE,EAAIyG,oBAAoBF,EAAQhS,EAAU6R,MAczD7Z,EAAOY,QACVuZ,UAAWJ,EACXpC,OAAQ,WACJmC,EAAOzV,QAAQ2V,GAAUD,EAAYC,GAAQrC,cCnCzD,MACMyC,GAAwB,IAAI7H,WjBGA8H,IAAO9C,EAAO8C,GAAK5L,QAAQ,wBAAyB,QiBHxC6L,CADhB,eA8EfC,qBA3EkBxK,GAC7BjJ,WAAW2M,GACP,IAAI8F,EAAgB,GAEpB,OADAhK,GAAiBkE,GAAK1K,KAAK+O,GAAQsC,GAAiBtQ,KAAKgO,KAAUyB,EAAgBzB,IAC5EyB,EAIX7R,KAAK6R,EAAexF,GAChBnS,KAAKiP,MAAqB0I,EAC1B3X,KAAK4Y,WAAsB,IAAIjI,OAAO6H,IAAmBnF,KAAKsE,GAAe,GAC7E3X,KAAK+O,kBAAqBvB,GAAmB2E,GAAa,IAS9D0G,YAAYxK,EAASyK,GACjB,MAAMvK,EAAQ9I,GAAQlH,IAAI8P,GAE1B,IAAI0K,EACJxK,EAAMD,KAAK0K,IAAMF,EAEjB,IACIC,EAAa/Y,KAAK+O,kBAAkBR,EAAMD,MAE9C,MAAMpO,GAEF,YADAqN,GAASrN,GAMb,UAFOqO,EAAMD,KAAK0K,IAEd,mBAAsBD,EACtB,OAAOA,EAAWlb,KAAKwQ,EAAQiB,GAAIwJ,GAG9BC,GAAc,aAAeA,EAAWF,aAC7CE,EAAWF,YAAYhb,KAAKkb,EAAYD,GAKhD1K,OAAOC,EAAST,EAAMU,GAClB,IAAIC,EAAQ9I,GAAQlH,IAAI8P,GAEnBE,IACDA,GACID,MAAc2K,UACdvK,QAAY,IAAM1O,KAAKoO,OAAOC,EAAST,EAAMW,EAAMD,OAEvD7I,GAAQnE,IAAI+M,EAASE,IAGrBD,IACIA,EAAK2K,MACL1K,EAAMD,KAAOA,EAGbC,EAAMD,KAAK2K,MAAQ3K,GAK/BU,eAAepB,GACX,MAAMS,EAAUkB,MAAMP,eAAepB,GAC/BsL,EAAanB,GAAoBnK,EAAM5N,KAAK4Y,WAAY5Y,KAAK6Y,YAAY3Z,KAAKc,KAAMqO,IAE1F,OADAA,EAAQlI,UAAU,IAAM+S,EAAWnD,UAC5B1H,ICxER,SAAS8K,GAAW9W,EAAK+D,GACvB/D,EAAIyG,KACLoC,GAAmB7I,GAGnB+D,GACA/D,EAAIyG,IAAuBgB,cAAc1D,GAG7C,MAAM4D,EAAU,IAAM3H,EAAIyG,IAAuBsB,SAAS1I,OAAO0E,GAEjE,OADA4D,EAAQjE,QAAUiE,EACXA,ECDX,MAAMgM,GAAgB,QAChBoD,GAAgB,OAChBC,GAAgB,OAChBC,GAAgBC,GACVhX,EAAMD,QAAQiX,KAAUA,EAAK1Y,QAAYwI,GAAakQ,KAAUnb,EAAOgE,KAAKmX,GAAM1Y,OA8T9F,SAAS2Y,KAIL,IAAK,IAAI9b,EAAI,EAAGkB,EAAIoB,KAAK8W,UAAUjW,OAAQnD,EAAIkB,EAAGlB,IAC9CsC,KAAK8W,UAAUpZ,GAAGmS,YAAc7P,KAAK8W,UAAUpZ,GAAGmS,WAAW3C,YAAYlN,KAAK8W,UAAUpZ,IAGxFsC,KAAKyZ,MAAMC,QACX1Z,KAAK2Z,OAAOC,aAAalY,OAAO1B,KAAKyZ,MAAMC,QAG/C1Z,KAAK2Z,OAAS,KACd3Z,KAAK2M,IAAoB5G,UAoBd8T,qBA3UoB1L,GAC/BjJ,WAAW2M,GACP,OAAOlO,GAAakO,EAAKmE,IAAaA,GAAY,GAGtD9Q,iBAAmB,OAAO,EAG1BY,KAAKoQ,EAAM/D,GACP,MAAQ2H,EAAcC,GAiT9B,SAA6B5H,GACzB,IAAI6H,EAAU,gCAAgC3G,KAAKlB,GACnD,OAAI6H,IACAA,EAAUA,EAAQhW,MAAM,IAChB,GAAKgW,EAAQ,GAAGpE,MAAM,KAAKvB,IAAI4F,GAAWtE,EAAOsE,GAASvM,QAC3DsM,MAtT2BE,EAAqB/H,GAAa,IAAIzE,QACxE1N,KAAKiP,MAAqBiH,EAC1BlW,KAAKma,cAAqBL,EAC1B9Z,KAAK+O,kBAAqBvB,GAAmBuM,GAAW,IAG5D3L,OAAOC,EAAST,EAAMU,GAClBiB,MAAMnB,OAAOC,EAAST,EAAMU,GAC5B,MAAMC,EAAQ9I,GAAQlH,IAAI8P,GAErBE,EAAME,SACPF,EAAM6L,WACN7L,EAAMqL,aAAe,IAAI1N,GACzBqC,EAAM8L,aAAe,KAAMra,KAAKsa,gBAAgBjM,EAASE,EAAM5P,QAC/D4P,EAAMgM,eAAgB,EACtBhM,EAAMiM,SAAU,EAChBjM,EAAMkM,OAASpB,GACf9K,EAAME,OAASiM,KACPA,IAAYnM,EAAM5P,QAGb4P,EAAM5P,QACX4P,EAAM5P,MAAQ,KAEV4P,EAAM8L,aAAa1L,iBACnBJ,EAAM8L,aAAa1L,mBAItB+L,GAKL/O,GAAuB4C,EAAMG,SAC7BH,EAAM5P,MAAQ+b,EAGd3Q,GAAe2Q,GAEXnY,EAAMD,QAAQoY,GACdvB,GAAWuB,EAASnM,EAAM8L,cAErBhR,GAAaqR,IAClBlR,GAAgBkR,EAAS,KAAMnM,EAAM8L,cAGrCf,GAAYoB,IAAYnM,EAAM6L,QAC9Bpa,KAAK2a,oBAAoBpM,EAAM6L,QAAS/L,GAGxCrO,KAAKsa,gBAAgBjM,EAASqM,IArB9B1a,KAAK2a,oBAAoBpM,EAAM6L,QAAS/L,MA0BhDA,EAAQlI,UAAU,KACVoI,EAAM8L,aAAa1L,iBACnBJ,EAAM8L,aAAa1L,kBAEvBJ,EAAMqL,aAAa9U,QACnB9E,KAAK2a,oBAAoBpM,EAAM6L,QAAS/L,MAWpDsM,oBAAoBP,EAAS/L,GACzB,GAAK+L,GAAYA,EAAQvZ,OAMzB,GAFAuZ,EAAUA,EAAQxX,OAAO,GAErByL,EAAQuM,aAAc,CACtB,MAAMC,EAAYxM,EAAQ6I,gBAAgBrH,WAC1CgL,EAAUC,YAAc,GACxBD,EAAUpX,YAAY4K,EAAQ6I,iBAC9B5R,EAAW,KACPyH,GAAaqN,EAASW,GAAUA,EAAOC,mBAI3CjO,GAAaqN,EAASW,GAAUA,EAAOC,YA4B/CC,oBAAoBlX,EAAQmX,GACxB,OAAOlb,KAAKma,cAAcvT,OACtB,CAACuU,EAASlB,KACNkB,EAAQlB,GAAWlW,EAAOhD,QACnBoa,GAEXD,OAWRZ,gBAAgBjM,EAAS+M,GACrB,MAAM7M,EAAoB9I,GAAQlH,IAAI8P,GAChCgN,KACAC,EAAoBjO,KAC1B,IACIiB,EADAhM,EAAsBC,EAAMD,QAAQ8Y,GAGxC,GAAI9Y,EACAA,GAAU,EACVgM,EAAO8M,MAEN,KAAI/R,GAAa+R,GAGlB,OAFA9M,EAAOlQ,EAAOgE,KAAKgZ,GAKvB,IAAK,IAAI1d,EAAI,EAAGkB,EAAI0P,EAAKzN,OAAQnD,EAAIkB,EAAGlB,IAAK,CACzC,IAAIyd,GAAYlC,MAAO1K,EAAMD,KAAK2K,OAAS1K,EAAMD,MAE7ChM,EACAtC,KAAKib,qBAAsB3M,EAAK5Q,GAAIA,GAAKyd,GAGzCnb,KAAKib,qBAAsBG,EAAS9M,EAAK5Q,IAAM4Q,EAAK5Q,GAAIA,GAAKyd,GAGjE,MAAMJ,EAAS/a,KAAKub,aAAalN,EAAS8M,GAC1CJ,EAAOtB,MAAM+B,IAAM9d,EACnB2d,EAAkBzW,KAAKmW,GACvBO,EAAe7X,YAAYsX,GAG3BO,EAAe7G,iBACf/Q,GAAa2K,EAAQ6I,gBAAgBrH,WAAYyL,EAAgBjN,EAAQ6I,iBAM7EnK,GAAawB,EAAM6L,QAAQxX,OAAO,EAAG2L,EAAM6L,QAAQvZ,UAAWwa,GAAoBI,KAC9B,IAA5CJ,EAAkB3Y,QAAQ+Y,IAC1BA,EAAYT,aAIhBzM,EAAM6L,QAAQvZ,QACdb,KAAK0b,iBACDrN,EAAQ6I,gBAAgBrH,WACxBxB,EAAQ6I,gBACR3I,EAAM6L,SAiBlBmB,aAAalN,EAAS8M,GAClB,MAAM5M,EAAY9I,GAAQlH,IAAI8P,GAC9B,IAEIsN,EAFAC,EAAc,KACdlC,EAAcnL,EAAMkM,OAAOU,GAQ/B,OALIzB,IACAiC,EAAepN,EAAMqL,aAAarb,IAAImb,IAItCiC,UACOR,EAAQlC,MACf0C,EAAahP,IAAoBiF,QAAQuJ,GACzCS,EAAaD,IAMjBA,EAAevN,GAAOC,EAAQiB,GAAGhB,KAAM6M,EAAS9M,EAAQ+C,aAIpD7C,EAAMgM,gBACNhM,EAAMgM,eAAgB,EAGiB,IAAnCoB,EAAa1L,WAAWpP,QACa,IAArC8a,EAAajH,WAAWxF,UACxBvL,GAAagY,EAAajH,WAAY0E,MAEtC7K,EAAMiM,SAAU,EAChBjM,EAAMkM,OAASjN,GAAkBP,GAAa0O,EAAajH,WAAY0E,KACvEM,EAASnL,EAAMkM,OAAOU,KAI1B5M,EAAMiM,SACN3W,GAAgB8X,EAAajH,WAAY0E,IAG7CuC,EAAa7E,UAAY9J,GAAW2O,EAAa1L,WAAY,GAC7D0L,EAAaX,SAAWxB,GACxBmC,EAAahC,OAASpL,EACtBoN,EAAalC,OAAWoC,OAAQF,EAAcjC,SAAQ8B,KAAM,GAExD9B,GACAnL,EAAMqL,aAAatY,IAAIoY,EAAQiC,GAGnCC,EAAaD,GAUjBD,iBAAiBI,EAAeC,EAAgBC,GAE5CjP,GAAaiP,EAAiB,CAACP,EAAajI,KACpCiI,EAAYhC,MAAM+B,MAAQhI,IAI9B9P,GACIoY,EACAL,EAAYhC,MAAMoC,OAClBG,EAAgBxI,EAAQ,GAAKwI,EAAgBxI,EAAQ,GAAGiG,MAAMoC,OAASE,GAE3EN,EAAYhC,MAAM+B,IAAMhI,KAIhCxE,eAAepB,EAAMqD,GACjB,MAAM5C,EAAoBkB,MAAMP,eAAepB,GAO/C,OANAS,EAAQ+C,YAAkBH,EAC1B5C,EAAQ6I,gBAAkB/J,GAAc,IACxCkB,EAAQuM,aAkChB,SAA4BhN,GACxB,OAAOrL,EAAMjD,UAAU2c,MAAMpe,KAAK+P,EAAKiC,WAAWI,WAAYiM,GACnDA,IAActO,GAAgC,IAAvBsO,EAAUhN,WAAmBgN,EAAUpB,YAAYpN,QApCvDyO,CAAmBvO,GAE7ClK,GAAakK,EAAKiC,WAAYxB,EAAQ6I,gBAAiBtJ,GACvDV,GAAYU,EAAKiC,WAAYjC,GACtBS,IC7Uf,MAAM2H,GAAY,QA4BHoG,qBA1BoBjO,GAC/BjJ,WAAW2M,GACP,OAAOlO,GAAakO,EAAKmE,IAAaA,GAAY,GAItDlQ,KAAKoQ,EAAM/D,GACPnS,KAAKiP,MAAqBiH,EAC1BlW,KAAK+O,kBAAqBvB,GAAmB2E,GAAa,IAG9D/D,OAAOC,EAAST,EAAMU,GAClBiB,MAAMnB,OAAOC,EAAST,EAAMU,GAC5B,MAAMC,EAAQ9I,GAAQlH,IAAI8P,GACrBE,EAAME,SACPF,EAAME,OAASI,KACPA,IAAaN,EAAM5P,QAIvBiP,EAAKuD,UAAYtC,QC7BjCrR,EAAAQ,EAAA2B,EAAA,mCAAA0c,KAAA7e,EAAAQ,EAAA2B,EAAA,kCAAA2c,KAAA9e,EAAAQ,EAAA2B,EAAA,gCAAA4c,KAAA/e,EAAAQ,EAAA2B,EAAA,2BAAA6c,KAAAhf,EAAAQ,EAAA2B,EAAA,8BAAA8c,KAAAjf,EAAAQ,EAAA2B,EAAA,kCAAA+c,KAAAlf,EAAAQ,EAAA2B,EAAA,gCAAAgd,KAAAnf,EAAAQ,EAAA2B,EAAA,mCAAAid,KAAApf,EAAAQ,EAAA2B,EAAA,mCAAAkd,KAAArf,EAAAQ,EAAA2B,EAAA,kCAAAmd,KAAAtf,EAAAQ,EAAA2B,EAAA,kCAAAod,KAAAvf,EAAAQ,EAAA2B,EAAA,kCAAAqd,KAAAxf,EAAAQ,EAAA2B,EAAA,gCAAAsd,KAAAzf,EAAAQ,EAAA2B,EAAA,kCAAAud,KAcA,MAAMZ,IACFzC,GACA5C,GACAhB,GACAK,GACAc,GACAI,GACAM,GACAa,GACAyD,IAGEC,GAAiBtH,GAAYtO,SACnC4V,GAAepL,WAAaqL,GAEbD","file":"dom-data-bind.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"DomDataBind\"] = factory();\n\telse\n\t\troot[\"DomDataBind\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","\r\nexport const GLOBAL = (() => {\r\n    const undef = 'undefined';\r\n    /* global self, window, global */\r\n    if (typeof window !== undef) { return window; }\r\n    if (typeof global !== undef) { return global; }\r\n    if (typeof self !== undef) { return self; }\r\n    return Function('return this;')();\r\n})();\r\n\r\nexport function getGlobal() {\r\n    return GLOBAL;\r\n}\r\nexport default getGlobal;","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","const OBJECT_TYPE   = \"[object Object]\";\r\nconst _toString     = Function.call.bind(Object.prototype.toString);\r\nconst _hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\r\n\r\n//============================================================\r\n\r\n/**\r\n * Extends an object with the properties of another.\r\n *\r\n * @param {Object|Boolean} mergeIntoObj\r\n *  The object that will have the properties of every other object provided\r\n *  on input merged into. This can also be a `Boolean`, in which case,\r\n *  a deep merge of objects will be done - argument number 2 will\r\n *  become the `mergeIntoObj`.\r\n * @param {...Object} mergeObjects\r\n *\r\n * @return {Object}\r\n */\r\nexport function objectExtend(mergeIntoObj, ...mergeObjects) {\r\n    let response    = mergeIntoObj || {};\r\n    let total       = mergeObjects.length;\r\n    let deepMerge   = false;\r\n    let i;\r\n    let key;\r\n\r\n    if (typeof mergeIntoObj === \"boolean\") {\r\n        deepMerge   = mergeIntoObj;\r\n        response    = mergeObjects.shift() || {};\r\n        total       = mergeObjects.length;\r\n    }\r\n\r\n    for (i = 0; i < total; i++) {\r\n        if (!mergeObjects[i]) {\r\n            continue;\r\n        }\r\n\r\n        for (key in mergeObjects[i]) {\r\n            if (_hasOwnProperty(mergeObjects[i], key)){\r\n                if (\r\n                    deepMerge &&\r\n                    _toString(response[key]) === OBJECT_TYPE &&\r\n                    _toString(mergeObjects[i][key]) === OBJECT_TYPE\r\n                ) {\r\n                    response[key] = objectExtend( true, response[key], mergeObjects[i][key]);\r\n\r\n                } else {\r\n                    response[key] = mergeObjects[i][key];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return response;\r\n}\r\nexport default objectExtend;","// POLYFILL FOR WeakMap\r\n//  [pt] changed how \"delete\" is defined so that it can work in IE8\r\n\r\n/* jshint ignore:start */\r\n/**\r\n * @license\r\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n */\r\nvar FakeWeakMap;\r\nif (typeof WeakMap === 'undefined') {\r\n    (function() {\r\n        var defineProperty = Object.defineProperty;\r\n        var counter = Date.now() % 1e9;\r\n\r\n        var WeakMap = FakeWeakMap = function() {\r\n            this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');\r\n        };\r\n\r\n        WeakMap.prototype = {\r\n            set: function(key, value) {\r\n                var entry = key[this.name];\r\n                if (entry && entry[0] === key)\r\n                    entry[1] = value;\r\n                else\r\n                    defineProperty(key, this.name, {value: [key, value], writable: true});\r\n                return this;\r\n            },\r\n            get: function(key) {\r\n                var entry;\r\n                return (entry = key[this.name]) && entry[0] === key ?\r\n                    entry[1] : undefined;\r\n            },\r\n            // [pt] Quotes around the delete property needed for IE8\r\n            \"delete\": function(key) {\r\n                var entry = key[this.name];\r\n                if (!entry || entry[0] !== key) return false;\r\n                entry[0] = entry[1] = undefined;\r\n                return true;\r\n            },\r\n            has: function(key) {\r\n                var entry = key[this.name];\r\n                if (!entry) return false;\r\n                return entry[0] === key;\r\n            }\r\n        };\r\n\r\n        window.WeakMap = WeakMap;\r\n    })();\r\n} else {\r\n    FakeWeakMap = WeakMap\r\n}\r\n/* jshint ignore:end */\r\nexport { FakeWeakMap as WeakMap };\r\nexport default FakeWeakMap;\r\n","import {WeakMap} from \"./WeakMap\";\r\n\r\n/**\r\n * Returns an object that contains an initialized WeakMap (`stash` property)\r\n * where data can be stored.\r\n *\r\n * @namespace dataStore\r\n *\r\n */\r\nvar dataStore = /** @lends dataStore */{\r\n    /**\r\n     * Stash data here.\r\n     * @type WeakMap\r\n     */\r\n    stash:  new WeakMap(),\r\n    /**\r\n     * Create a private data store and return it.\r\n     * @return {WeakMap}\r\n     */\r\n    create: function(){\r\n        return new WeakMap();\r\n    }\r\n};\r\n\r\nexport default dataStore;\r\nexport { dataStore };\r\n","/**\r\n * return a value to a given method\r\n *\r\n * @function\r\n * @param {Function} fn\r\n * @param {*} ctx The context to be assigned to `fn`\r\n * @return {Function}\r\n *\r\n * @example\r\n *\r\n * f = functionBin(function() { console.log(`Hello ${this.name}`); }, { name: \"Jackson\" });\r\n * f(); // => \"Hello Jackson\"\r\n */\r\nexport const functionBind = Function.bind.call.bind(Function.bind);\r\n\r\n/**\r\n * return a bound `.call` to the given method.\r\n *\r\n * @type function\r\n * @param {Function} fn\r\n * @return {Function}\r\n * @example\r\n *\r\n * forEach = functionBindCall(Array.prototype.forEach);\r\n * // same as doing: Array.prototype.forEach.call (but returns a new \"call\" method);\r\n */\r\nexport const functionBindCall = functionBind(Function.call.bind, Function.call);\r\n\r\n// Object ===============================================================================\r\nexport const isObject                 = obj => Object.prototype.toString.call(obj) === \"[object Object]\";\r\nexport const objectDefineProperty     = Object.defineProperty;\r\nexport const objectDefineProperties   = Object.defineProperties;\r\nexport const objectKeys               = Object.keys;\r\nexport const defineProperty = (obj, prop, value, getter, setter, configurable = true, enumerable = false, writable = true) => {\r\n    const descriptor = {\r\n        configurable,\r\n        enumerable\r\n    };\r\n\r\n    if (getter || setter) {\r\n        descriptor.get = getter;\r\n        descriptor.set = setter;\r\n    } else {\r\n        descriptor.writable = writable;\r\n        descriptor.value = value;\r\n    }\r\n\r\n    objectDefineProperty(obj, prop, descriptor);\r\n\r\n    return obj;\r\n};\r\n\r\n\r\n// Array ===============================================================================\r\nconst arr = [];\r\nexport const isArray        = Array.isArray;\r\nexport const arrayForEach   = functionBindCall(arr.forEach);\r\nexport const arrayIndexOf   = functionBindCall(arr.indexOf);\r\nexport const arraySplice    = functionBindCall(arr.splice);\r\n\r\n\r\n// Logging ===============================================================================\r\nexport const consoleLog = console.log; // eslint-disable-line\r\nexport const consoleError = console.error || consoleLog; // eslint-disable-line\r\nexport const consoleWarn = console.warn || consoleLog; // eslint-disable-line\r\n\r\n\r\n// Iterators ===============================================================================\r\nexport const SymbolIterator = \"undefined\" !== typeof Symbol && Symbol.iterator ? Symbol.iterator : \"@@iterator\";\r\n\r\n\r\n// DOM ===============================================================================\r\nconst HTMLElementPrototype = HTMLElement.prototype;\r\nexport const doc = document;\r\nexport const head = doc.head;\r\nexport const createDocFragment = () => doc.createDocumentFragment();\r\nexport const createElement = tagName => doc.createElement(tagName);\r\nexport const createTextNode = data => doc.createTextNode(data || \"\");\r\nexport const appendChild = functionBindCall(HTMLElementPrototype.appendChild);\r\nexport const insertBefore = functionBindCall(HTMLElementPrototype.insertBefore);\r\nexport const hasAttribute = functionBindCall(HTMLElementPrototype.hasAttribute);\r\nexport const setAttribute = functionBindCall(HTMLElementPrototype.setAttribute);\r\nexport const removeAttribute = functionBindCall(HTMLElementPrototype.removeAttribute);","import {\r\n    objectDefineProperty,\r\n    objectDefineProperties,\r\n    SymbolIterator\r\n} from \"./runtime-aliases\"\r\n\r\n//-----------------------------------------------------------------------\r\n\r\n// Great reference: http://2ality.com/2015/02/es6-iteration.html\r\nexport function FakeIterator(keys, values) {\r\n    objectDefineProperty(this, \"_\", { value: {\r\n        keys:   keys.slice(0),\r\n        values: values ? values.slice(0) : null,\r\n        idx:    0,\r\n        total:  keys.length\r\n    } });\r\n}\r\nexport default FakeIterator;\r\n\r\nobjectDefineProperties(FakeIterator.prototype, {\r\n    constructor: { value: FakeIterator },\r\n    next: {\r\n        enumerable: true,\r\n        configurable: true,\r\n        value() {\r\n            const response = {\r\n                done: this._.idx === this._.total\r\n            };\r\n\r\n            if (response.done) {\r\n                response.value = undefined;\r\n                return response;\r\n            }\r\n\r\n            const nextIdx = this._.idx++;\r\n\r\n            response.value = this._.keys[nextIdx];\r\n\r\n            if (this._.values) {\r\n                response.value = [ response.value, this._.values[nextIdx] ];\r\n            }\r\n\r\n            return response;\r\n        }\r\n    }\r\n});\r\nobjectDefineProperty(FakeIterator.prototype, SymbolIterator, { value(){ return this; } });\r\n\r\n","import { GLOBAL } from \"./getGlobal\"\r\nimport { FakeIterator } from \"./Iterator\"\r\nimport {\r\n    objectDefineProperties,\r\n    objectDefineProperty,\r\n    arrayIndexOf,\r\n    SymbolIterator\r\n} from \"./runtime-aliases\"\r\n\r\n//============================================================\r\n\r\nexport const Set = GLOBAL.Set && GLOBAL.Set.prototype[SymbolIterator] ? GLOBAL.Set : FakeSet;\r\nexport default Set;\r\n\r\nexport function FakeSet() {\r\n    // FIXME: support for iterable input\r\n}\r\n\r\nobjectDefineProperties(FakeSet.prototype, {\r\n    constructor: { value: FakeSet, configurable: true },\r\n    _: {\r\n        get() {\r\n            const values = [];\r\n            objectDefineProperty(this, \"_\", { value: values });\r\n            return values;\r\n        }\r\n    },\r\n    add: {\r\n        value(item) {\r\n            if (arrayIndexOf(this._, item) === -1) {\r\n                this._.push(item);\r\n            }\r\n            return this;\r\n        }\r\n    },\r\n    has: {\r\n        value(item) { return arrayIndexOf(this._, item) !== -1; }\r\n    },\r\n    size: {\r\n        get() { return this._.length; }\r\n    },\r\n    clear: {\r\n        value() { this._.splice(0); }\r\n    },\r\n    delete: {\r\n        value(item) {\r\n            const idx = arrayIndexOf(this._, item);\r\n            if (idx !== -1) {\r\n                this._.splice(idx, 1);\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    values: {\r\n        value() {\r\n            return new FakeIterator(this._);\r\n        }\r\n    },\r\n    entries: {\r\n        value() {\r\n            return new FakeIterator(this._, this._);\r\n        }\r\n    },\r\n    forEach: {\r\n        value(cb, thisArg) {\r\n            this._.forEach(item => cb(item, item, this), thisArg);\r\n        }\r\n    },\r\n    [SymbolIterator]: {\r\n        value() {\r\n            return this.values();\r\n        }\r\n    }\r\n});\r\n\r\n\r\n","import Set from \"./es6-Set\"\r\n\r\n//===============================================\r\nconst callbacks = new Set();\r\nlet queue;\r\n\r\n/**\r\n * Queue a callback to be executed after at the start of next event loop.\r\n * This differs from `nextTick` in that callbacks are not executed during\r\n * micro-processing, but rather on next event loop, so this is not ideal\r\n * for logic that can cause UI reflow.\r\n *\r\n * @param {Function} cb\r\n */\r\nexport function queueCallback(cb) {\r\n    if (\"function\" === typeof cb) {\r\n        callbacks.add(cb);\r\n\r\n        if (!queue) {\r\n            queue = setTimeout(flushQueue, 0);\r\n        }\r\n    }\r\n}\r\nexport default queueCallback;\r\n\r\nfunction flushQueue() {\r\n    const cbList  = [...callbacks];\r\n    callbacks.clear();\r\n    queue = null;\r\n    let cb;\r\n    while ((cb = cbList.shift())) {\r\n        cb();\r\n        cb = null;\r\n    }\r\n}\r\n","import objectExtend from \"./objectExtend\"\r\nimport dataStore from \"./dataStore\"\r\nimport queueCallback from \"./queueCallback\"\r\n\r\n//=========================================================\r\nconst PRIVATE = dataStore.create();\r\nconst COMMON_DESTROY_METHOD_NAME = [\r\n    \"destroy\",      // Compose\r\n    \"remove\",       // DOM Events Listeners\r\n    \"off\"           // EventEmitter Listeners\r\n];\r\n\r\n// return all KEYs of an object, even those that are not iterable\r\nfunction objectKeys(prototype){\r\n    let k, keys = [];\r\n    for (k in prototype){\r\n        keys.push(k);\r\n    }\r\n    return keys;\r\n}\r\n\r\n// Base instance methods for Compose'd object\r\nconst baseMethods = /** @lends Compose.prototype */{\r\n\r\n    /**\r\n     * Property indicating whether instance has been destroyed\r\n     */\r\n    isDestroyed: false,\r\n\r\n    /**\r\n     * instance initializing code\r\n     */\r\n    init(){},\r\n\r\n    /**\r\n     * Destroys the instance, by removing its private data.\r\n     * Any attached `onDestroy` callback will be executed `async` - queued and\r\n     * called on next event loop\r\n     *\r\n     * @param {Boolean} [executeCallbacksNow=false]\r\n     */\r\n    destroy(executeCallbacksNow){\r\n        if (PRIVATE.has(this)) {\r\n            let destroyCallbacks = PRIVATE.get(this);\r\n            PRIVATE.delete(this);\r\n\r\n            if (executeCallbacksNow) {\r\n                destroyCallbacks.forEach(callOnDestroyCallback);\r\n            }\r\n            else {\r\n                queueCallback(() => destroyCallbacks.forEach(callOnDestroyCallback));\r\n            }\r\n        }\r\n\r\n        if (\"boolean\" === typeof this.isDestroyed) {\r\n            this.isDestroyed = true;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds a callback to the queue to be called when this object's `.destroy()`\r\n     * is called.\r\n     *\r\n     * @param {Function} callback\r\n     */\r\n    onDestroy(callback){\r\n        getInstanceState(this).push(callback);\r\n    },\r\n\r\n    /**\r\n     * Returns the factory for this instance.\r\n     *\r\n     * @return {Compose}\r\n     */\r\n    getFactory(){\r\n        if (this.constructor) {\r\n            return this.constructor;\r\n        }\r\n    }\r\n};\r\n\r\n\r\nconst staticMethods = /** @lends Compose */{\r\n    /**\r\n     * Creates an new factory based on the prototye of the current Factory\r\n     * and any other Factory given on input.\r\n     *\r\n     * @return {Compose}\r\n     */\r\n    extend: function(...args){\r\n        let Class = class extends this {};\r\n\r\n        objectExtend(Class.prototype, args.reduce(function(newProto, obj){\r\n            if (obj) {\r\n                const thisObjProto = (obj.prototype || obj);\r\n                objectKeys(thisObjProto).forEach(function(objKey){\r\n                    newProto[objKey] = thisObjProto[objKey];\r\n                });\r\n            }\r\n            return newProto;\r\n        }, {}));\r\n\r\n        return Class;\r\n    },\r\n\r\n    /**\r\n     * Checks if the Object given on input looks like an instance of this Factory.\r\n     *\r\n     * @return {Boolean}\r\n     */\r\n    isInstanceOf: function(instanceObj){\r\n\r\n        if (!instanceObj) {\r\n            return false;\r\n        }\r\n\r\n        var neededKeys = objectKeys(this.prototype);\r\n\r\n        // If any prototype key is not in the object prototype, then return false\r\n        return !neededKeys.some(function(protoKey){\r\n            return typeof instanceObj[protoKey] === \"undefined\";\r\n        });\r\n\r\n    },\r\n\r\n    /**\r\n     * Creates an instance object based on this factory.\r\n     *\r\n     * @return {Object}\r\n     */\r\n    create: function(){\r\n        return new this(...arguments);\r\n    },\r\n\r\n    /**\r\n     * Returns a standard callback that can be used to remove cleanup instance state\r\n     * from specific Store (WeakMap). Returned function will destroy known Instances\r\n     * that have destroy methods.\r\n     *\r\n     * @param {Object} instanceState\r\n     * @param {WeakMap} [stateStore]\r\n     *\r\n     * @return {Function}\r\n     *\r\n     * @example\r\n     *\r\n     * const MY_PRIVATE = new WeakMap();\r\n     * cont NewWdg = Componse.extend({\r\n     *      init() {\r\n     *          const state = {};\r\n     *          MY_PRIVATE.set(this, state);\r\n     *          ...\r\n     *\r\n     *          this.onDestroy(Compose.getDestroyCallback(state, MY_PRIVATE));\r\n     *      }\r\n     * });\r\n     */\r\n    getDestroyCallback: getDestroyCallback\r\n};\r\n\r\n\r\n/**\r\n * Returns a standard callback that can be used to remove cleanup instance state\r\n * from specific Store (WeakMap). Returned function will destroy known Instances\r\n * that have destroy methods.\r\n *\r\n * @method Compose~getDestroyCallback\r\n *\r\n * @param {Object} instanceState\r\n * @param {WeakMap} [stateStore]\r\n *\r\n * @return {Function}\r\n *\r\n * @example\r\n *\r\n * const MY_PRIVATE = new WeakMap();\r\n * cont NewWdg = Componse.extend({\r\n *      init() {\r\n *          const state = {};\r\n *          MY_PRIVATE.set(this, state);\r\n *          ...\r\n *\r\n *          this.onDestroy(Compose.getDestroyCallback(state, MY_PRIVATE));\r\n *      }\r\n * });\r\n */\r\nexport function getDestroyCallback (instanceState, stateStore) {\r\n    return () => {\r\n        if (instanceState) {\r\n            // Destroy all Compose object\r\n            Object.keys(instanceState).forEach(function (prop) {\r\n                if (instanceState[prop]) {\r\n                    COMMON_DESTROY_METHOD_NAME.some((method) => {\r\n                        if (\r\n                            instanceState[prop][method] &&\r\n                            (method !== \"remove\" || !(instanceState[prop] instanceof Node)) // Caution: should not remove DOM elements.\r\n                        ) {\r\n                            instanceState[prop][method]();\r\n                            return true;\r\n                        }\r\n                    });\r\n\r\n                    instanceState[prop] = undefined;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (stateStore && stateStore.has && stateStore.has(instanceState)) {\r\n            stateStore.delete(instanceState);\r\n        }\r\n    }\r\n}\r\n\r\nfunction getInstanceState(inst) {\r\n    if (!PRIVATE.has(inst)) {\r\n        PRIVATE.set(inst, []);\r\n    }\r\n\r\n    return PRIVATE.get(inst);\r\n}\r\n\r\nfunction callOnDestroyCallback (callback){\r\n    if (\"function\" === typeof callback) {\r\n        callback();\r\n    }\r\n}\r\n\r\nfunction getNewConstructor () {\r\n    function ComposeConstructor(...args) {\r\n        // Called with `new`?\r\n        if (this && this.constructor && this instanceof this.constructor) {\r\n            return this.init(...args);\r\n        }\r\n\r\n        // called directly\r\n        return new ComposeConstructor(...args);\r\n    }\r\n\r\n    ComposeConstructor.prototype.constructor = ComposeConstructor;\r\n    return ComposeConstructor;\r\n}\r\n\r\n/**\r\n * Composes new factory methods from a list of given Objects/Classes.\r\n *\r\n * @class Compose\r\n * @borrows Compose~getDestroyCallback as Compose.getDestroyCallback\r\n *\r\n * @example\r\n *\r\n * var Widget = Compose.create(Model, Events);\r\n *\r\n * myWidget = Widget.create();\r\n *\r\n */\r\nconst Compose = getNewConstructor();\r\nobjectExtend(Compose.prototype, baseMethods);\r\nobjectExtend(Compose, staticMethods);\r\n\r\nexport default Compose;\r\nexport { Compose };\r\n","/* global setImediate:true */\r\nlet reIsNativeCode = /native code/i;\r\n\r\n/**\r\n * Executes a function at the end of the current event Loop - during micro-task processing\r\n *\r\n * @param {Function} callback\r\n */\r\nlet nextTick = (function(){\r\n    if (typeof setImediate !== \"undefined\" && reIsNativeCode.test(setImediate.toString())) {\r\n        return setImediate;\r\n    }\r\n\r\n    // Native Promsie? Use it.\r\n    if (typeof Promise === 'function' && reIsNativeCode.test(Promise.toString())) {\r\n        let resolved = Promise.resolve();\r\n        return function _nextTickPromise(fn) {\r\n            resolved.then(fn).catch(e => console.error(e)); // eslint-disable-line\r\n        };\r\n    }\r\n\r\n    // fallback to setTimeout\r\n    // From: https://bugzilla.mozilla.org/show_bug.cgi?id=686201#c68\r\n    let immediates = [];\r\n    let processing = false;\r\n\r\n    function processPending() {\r\n        setTimeout(function() {\r\n            immediates.shift()();\r\n            if (immediates.length) {\r\n                processPending();\r\n            } else {\r\n                processing = false;\r\n            }\r\n        }, 0);\r\n    }\r\n\r\n    return function _nextTickSetTimeout(fn) {\r\n        immediates.push(fn);\r\n        if (!processing) {\r\n            processing = true;\r\n            processPending();\r\n        }\r\n    };\r\n})();\r\n\r\nlet isQueued = false;\r\nconst queuedCallbacks = new Set();\r\nlet i, t;\r\nconst flushQueue = () => {\r\n    const callbacks = [ ...queuedCallbacks ];\r\n    queuedCallbacks.clear();\r\n    isQueued = false;\r\n    for (i = 0, t = callbacks.length; i < t; i++) {\r\n        callbacks[i]();\r\n    }\r\n};\r\n\r\n/**\r\n * Queues a callback to be executed on nextTick. Unlike calling `nextTick` directly\r\n * `queue()` will ensure that the same callback is not executed more than once when\r\n * `nextTick` runs.\r\n *\r\n * @param {Function} callback\r\n */\r\nnextTick.queue = callback => {\r\n    queuedCallbacks.add(callback);\r\n    if (!isQueued) {\r\n        isQueued = true;\r\n        nextTick(flushQueue);\r\n    }\r\n};\r\n\r\nexport default nextTick;\r\nexport { nextTick };\r\n","import {objectDefineProperty, objectKeys, isArray} from \"@purtuga/common/src/jsutils/runtime-aliases\";\r\nimport Set from \"@purtuga/common/src/jsutils/Set\"\r\nimport nextTick from \"@purtuga/common/src/jsutils/nextTick\"\r\n\r\n//---------------------------------------------------------------------------\r\nexport const OBSERVABLE_IDENTIFIER = \"___$observable$___\"; // FIXME: this should be a Symbol()\r\n\r\nconst DEFAULT_PROP_DEFINITION = { configurable: true, enumerable: true };\r\nconst TRACKERS = new Set();\r\nconst WATCHER_IDENTIFIER = \"___$watching$___\";\r\nconst ARRAY_WATCHABLE_PROTO = \"__$watchable$__\";\r\nconst HAS_ARRAY_WATCHABLE_PROTO = `__$is${ARRAY_WATCHABLE_PROTO}`;\r\nconst ARRAY_MUTATING_METHODS = [\r\n    \"pop\",\r\n    \"push\",\r\n    \"shift\",\r\n    \"splice\",\r\n    \"unshift\",\r\n    \"sort\",\r\n    \"reverse\"\r\n];\r\nconst isPureObject = obj => obj && Object.prototype.toString.call(obj) === \"[object Object]\";\r\nconst NOTIFY_QUEUE = new Set();\r\nlet isNotifyQueued = false;\r\n\r\n/**\r\n * A lightweight utility to Watch an object's properties and get notified when it changes.\r\n *\r\n * @param {Object} obj\r\n *\r\n * @param {String} [prop]\r\n *  the property to be watched. If left undefined, then all existing properties are watched.\r\n *\r\n * @param {Function} [callback]\r\n *  The callback to be executed when property or object changes. If left undefined, then\r\n *  `obj` is only made observable (internal structure created and all current enumerable'\r\n *  properties are made \"watchable\")\r\n *\r\n *  __NOTE:__\r\n *  The callback will include a new non-enumerable property named `stopWatchingAll` of\r\n *  type `Function` that can be used to remove the given callback from all places where\r\n *  it is being used to watch a property. example:\r\n *\r\n *      const obj1 = { first: \"john\" };\r\n *      const obj2 = { last: \"smith\" };\r\n *      const watcher = () => console.log(\"changed\");\r\n *\r\n *      objectWatchProp(obj, \"first\", watcher);\r\n *      objectWatchProp(obj1, \"last\", watcher);\r\n *\r\n *      watcher.stopWatchingAll(); // removes callback from all objects that it is watching\r\n *\r\n *\r\n * @return {ObjectUnwatchProp}\r\n * Return a function to unwatch the property. Function also has a static property named\r\n * `destroy` that will do the same thing (ex. `unwatch.destroy()` is same as `unwatch()`)\r\n *\r\n * @example\r\n *\r\n * const oo = {};\r\n * const notifyNameChanged =() => console.log(`name changed: ${oo.name}`);\r\n * const unWatchName = objectWatchProp(oo, \"name\", notifyNameChanged);\r\n *\r\n * oo.name = \"paul\"; // console outputs: name changed: paul\r\n * unWatchName(); // stop watching\r\n * notifyNameChanged.stopWatchingAll(); // callback's `stopWatchingAll()` can also be called.\r\n *\r\n * @example\r\n *\r\n * const oo = {\r\n *      name: \"paul\",\r\n *      country: \"usa\"\r\n * };\r\n *\r\n * // watch all changes to object\r\n * objectWatchProp(oo, null, () => console.log(\"Something changed in object\"));\r\n *\r\n * // OR: make all properties of object observable\r\n * objectWatchProp(oo);\r\n *\r\n */\r\nexport function objectWatchProp(obj, prop, callback) {\r\n    if (!obj[OBSERVABLE_IDENTIFIER]) {\r\n        setupObjState(obj);\r\n    }\r\n\r\n    // Convert prop to observable?\r\n    if (prop && !obj[OBSERVABLE_IDENTIFIER].props[prop]) {\r\n        setupPropState(obj, prop);\r\n        setupPropInterceptors(obj, prop);\r\n    }\r\n    // Else: do we need to setup the interceptors (again)?\r\n    // (Used by Computed props when they are created against a prop has\r\n    // been setup as an observable)\r\n    else if (prop && obj[OBSERVABLE_IDENTIFIER].props[prop].setupInterceptors) {\r\n        setupPropInterceptors(obj, prop);\r\n    }\r\n\r\n    if (prop && callback) {\r\n        obj[OBSERVABLE_IDENTIFIER].props[prop].storeCallback(callback);\r\n    }\r\n    else if (!prop) {\r\n        makeObservable(obj, false);\r\n\r\n        if (callback) {\r\n            obj[OBSERVABLE_IDENTIFIER].storeCallback(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unwatch an object property or object.\r\n     *\r\n     * @typedef {Function} ObjectUnwatchProp\r\n     * @property {Function} destroy Same as function returned.\r\n     */\r\n    const unWatch = destroyWatcher.bind(\r\n        obj,\r\n        callback,\r\n        (prop ? obj[OBSERVABLE_IDENTIFIER].props[prop] : obj[OBSERVABLE_IDENTIFIER])\r\n    );\r\n\r\n    unWatch.destroy = unWatch;\r\n    return unWatch;\r\n}\r\n\r\nexport function setupObjState(obj) {\r\n    if (!obj[OBSERVABLE_IDENTIFIER]) {\r\n        objectDefineProperty(obj, OBSERVABLE_IDENTIFIER, {\r\n            configurable: true,\r\n            writable: true,\r\n            deep: false,\r\n            value: {\r\n                props: {},\r\n                dependents: new Set(),\r\n                watchers: new Set(),\r\n                storeCallback: storeCallback\r\n            }\r\n        });\r\n        setupCallbackStore(obj[OBSERVABLE_IDENTIFIER].dependents, false);\r\n        setupCallbackStore(obj[OBSERVABLE_IDENTIFIER].watchers, true);\r\n    }\r\n}\r\n\r\nfunction setupCallbackStore (store, async = false) {\r\n    store.async = async;\r\n    store.isQueued = false;\r\n    store.notify = notify;\r\n}\r\n\r\nfunction setupPropState(obj, prop) {\r\n    if (!obj[OBSERVABLE_IDENTIFIER].props[prop]) {\r\n        obj[OBSERVABLE_IDENTIFIER].props[prop] = {\r\n            val: undefined,\r\n            dependents: new Set(),\r\n            watchers: new Set(),\r\n            parent: obj[OBSERVABLE_IDENTIFIER],\r\n            storeCallback: storeCallback,\r\n            setupInterceptors: true,\r\n            deep: obj[OBSERVABLE_IDENTIFIER].deep\r\n        };\r\n        setupCallbackStore(obj[OBSERVABLE_IDENTIFIER].props[prop].dependents, false);\r\n        setupCallbackStore(obj[OBSERVABLE_IDENTIFIER].props[prop].watchers, true);\r\n    }\r\n    return obj[OBSERVABLE_IDENTIFIER].props[prop];\r\n}\r\n\r\nfunction setupPropInterceptors(obj, prop) {\r\n    const propOldDescriptor =\r\n        Object.getOwnPropertyDescriptor(obj, prop) || DEFAULT_PROP_DEFINITION;\r\n\r\n    if (!propOldDescriptor.get) {\r\n        obj[OBSERVABLE_IDENTIFIER].props[prop].val = obj[prop];\r\n\r\n        // If prop is marked as `deep` then walk the value and convert it to observables\r\n        if (obj[OBSERVABLE_IDENTIFIER].props[prop].deep) {\r\n            makeObservable(obj[OBSERVABLE_IDENTIFIER].props[prop].val);\r\n        }\r\n    }\r\n\r\n    objectDefineProperty(obj, prop, {\r\n        configurable: propOldDescriptor.configurable || false,\r\n        enumerable: propOldDescriptor.enumerable || false,\r\n        get() {\r\n            if (TRACKERS.size) {\r\n                TRACKERS.forEach(\r\n                    obj[OBSERVABLE_IDENTIFIER].props[prop].storeCallback,\r\n                    obj[OBSERVABLE_IDENTIFIER].props[prop]\r\n                );\r\n            }\r\n\r\n            if (propOldDescriptor.get) {\r\n                return propOldDescriptor.get.call(obj);\r\n            }\r\n\r\n            return obj[OBSERVABLE_IDENTIFIER].props[prop].val;\r\n        },\r\n        set(newVal) {\r\n            const priorVal = obj[prop];\r\n            if (propOldDescriptor.set) {\r\n                newVal = propOldDescriptor.set.call(obj, newVal);\r\n            } else {\r\n                obj[OBSERVABLE_IDENTIFIER].props[prop].val = newVal;\r\n            }\r\n\r\n            // If this `deep` is true and the new value is an object,\r\n            // then ensure its observable\r\n            if (obj[OBSERVABLE_IDENTIFIER].props[prop].deep) {\r\n                makeObservable(newVal);\r\n            }\r\n\r\n            if (newVal !== priorVal) {\r\n                obj[OBSERVABLE_IDENTIFIER].props[prop].watchers.notify();\r\n                obj[OBSERVABLE_IDENTIFIER].props[prop].dependents.notify();\r\n                obj[OBSERVABLE_IDENTIFIER].watchers.notify();\r\n            }\r\n\r\n            return newVal;\r\n        }\r\n    });\r\n\r\n    obj[OBSERVABLE_IDENTIFIER].props[prop].setupInterceptors = false;\r\n\r\n    // Notify object watchers that a new prop was added\r\n    if (propOldDescriptor === DEFAULT_PROP_DEFINITION) {\r\n        obj[OBSERVABLE_IDENTIFIER].watchers.notify();\r\n    }\r\n}\r\n\r\n/**\r\n * Makes an object (deep) observable.\r\n *\r\n * @param {Object|Array} obj\r\n * @param {Boolean} [walk=true]\r\n *  If `true` (default), the object's property values are walked and\r\n *  also make observable.\r\n * @param {Boolean} [force=false]\r\n *  if true, then even if object looks like it might have already been\r\n *  converted to an observable, it will still be walked\r\n *  (if `walk` is `true`)\r\n *\r\n * @return {Object|Array} Original `obj` is returned\r\n */\r\nexport function makeObservable(obj, walk = true, force = false) {\r\n    if (!isPureObject(obj) && !isArray(obj)) {\r\n        return obj;\r\n    }\r\n\r\n    if (!obj[OBSERVABLE_IDENTIFIER]) {\r\n        // OBJECT\r\n        if (isPureObject(obj)) {\r\n            setupObjState(obj, force);\r\n        }\r\n        // ARRAY\r\n        else if (isArray(obj)) {\r\n            makeArrayWatchable(obj, force);\r\n        }\r\n    }\r\n\r\n    // If object is marked as \"deep\" and we are not forcing the walk,\r\n    // then no need to do anything. Otherwise, mark this object as\r\n    // being `deep` and keep going\r\n    if (!force && obj[OBSERVABLE_IDENTIFIER].deep) {\r\n        return;\r\n    }\r\n    else if (walk) {\r\n        obj[OBSERVABLE_IDENTIFIER].deep = true;\r\n    }\r\n\r\n    if (isArray(obj)) {\r\n        walkArray(obj);\r\n    }\r\n    else {\r\n        walkObject(obj);\r\n    }\r\n\r\n    return obj;\r\n}\r\n\r\n\r\nfunction walkArray(arr, force) {\r\n    for (let i=0, t=arr.length; i<t; i++) {\r\n        makeObservable(arr[i], true, force);\r\n    }\r\n}\r\n\r\nfunction walkObject(obj, force) {\r\n    // make ALL props observable\r\n    const keys = objectKeys(obj);\r\n\r\n    for (let i=0, t=keys.length; i<t; i++) {\r\n        if (!obj[OBSERVABLE_IDENTIFIER].props[keys[i]]) {\r\n            setupPropState(obj, keys[i]);\r\n            setupPropInterceptors(obj, keys[i]);\r\n        }\r\n\r\n        // Do we need to walk this property's value?\r\n        if (\r\n            !obj[OBSERVABLE_IDENTIFIER].props[keys[i]].deep ||\r\n            force\r\n        ) {\r\n            obj[OBSERVABLE_IDENTIFIER].props[keys[i]].deep = true;\r\n\r\n            if (isPureObject(obj[keys[i]])) {\r\n                makeObservable(obj[keys[i]], true, force);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction notify() {\r\n    // this: new Set(). Set instance could have two additional attributes: async ++ isQueued\r\n\r\n    if (!this.size) {\r\n        return;\r\n    }\r\n\r\n    // If the watcher Set() is synchronous, then execute the callbacks now\r\n    if (!this.async) {\r\n        this.forEach(execCallback);\r\n\r\n    } else {\r\n        this.forEach(pushCallbacksToQueue);\r\n    }\r\n\r\n    queueCallbackAndScheduleRun();\r\n}\r\n\r\nexport function queueCallbackAndScheduleRun(cb) {\r\n    if (cb) {\r\n        pushCallbacksToQueue(cb);\r\n    }\r\n\r\n    if (isNotifyQueued || !NOTIFY_QUEUE.size) {\r\n        return;\r\n    }\r\n\r\n    isNotifyQueued = true;\r\n    nextTick(flushQueue);\r\n}\r\n\r\nfunction pushCallbacksToQueue(callback) {\r\n    NOTIFY_QUEUE.add(callback);\r\n}\r\n\r\nfunction execCallback(cb) {\r\n    cb();\r\n}\r\n\r\nfunction flushQueue() {\r\n    const queuedCallbacks = [...NOTIFY_QUEUE];\r\n    NOTIFY_QUEUE.clear();\r\n    isNotifyQueued = false;\r\n    for (let x=0, total=queuedCallbacks.length; x<total; x++) {\r\n        queuedCallbacks[x]();\r\n    }\r\n    queuedCallbacks.length = 0;\r\n}\r\n\r\nfunction storeCallback(callback) {\r\n    // this === PropState\r\n    if (callback.asDependent && this.dependents) {\r\n        setCallbackAsWatcherOf(callback, this.dependents);\r\n        this.dependents.add(callback);\r\n    } else {\r\n        setCallbackAsWatcherOf(callback, this.watchers);\r\n        this.watchers.add(callback);\r\n    }\r\n}\r\n\r\nexport function destroyWatcher(callback, propSetup) {\r\n    // this == obj\r\n    if (callback) {\r\n        // Object state does not have dependents\r\n        if (propSetup.dependents) {\r\n            propSetup.dependents.delete(callback);\r\n            unsetCallbackAsWatcherOf(callback, propSetup.dependents);\r\n        }\r\n        propSetup.watchers.delete(callback);\r\n        unsetCallbackAsWatcherOf(callback, propSetup.watchers);\r\n    }\r\n}\r\n\r\n/**\r\n * Sets a callback to be added to the list of watchers for any property\r\n * that is accessed after this function is called.\r\n *\r\n * @param {Function} callback\r\n *  The callback to be added to dependency list of watchers.\r\n *  NOTE: the callback will modified to include a new property\r\n *  `stopWatchingAll()` which can be used to remove the given callback\r\n *  from ALL dependencies that include it.\r\n *\r\n */\r\nexport function setDependencyTracker(callback) {\r\n    TRACKERS.add(callback);\r\n}\r\n\r\n/**\r\n * Removes a callback from being added to a property's watchers as they\r\n * are accessed.\r\n *\r\n * @param {Function} callback\r\n */\r\nexport function unsetDependencyTracker(callback) {\r\n    TRACKERS.delete(callback);\r\n}\r\n\r\n/**\r\n * Removes the given callback from all property watchers lists that it may\r\n * be included in.\r\n *\r\n * @param {Function} callback\r\n */\r\nexport function stopTrackerNotification(callback) {\r\n    if (callback[WATCHER_IDENTIFIER]) {\r\n        callback[WATCHER_IDENTIFIER].stopWatchingAll();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Store a reference to the Set instance provided on input, on the callback.\r\n * @private\r\n * @param {Function} callback\r\n * @param {Set} watchersSet\r\n */\r\nfunction setCallbackAsWatcherOf(callback, watchersSet) {\r\n    if (!callback[WATCHER_IDENTIFIER]) {\r\n        objectDefineProperty(callback, WATCHER_IDENTIFIER, {\r\n            configurable: true,\r\n            writable: true,\r\n            value: {\r\n                watching: new Set()\r\n            }\r\n        });\r\n        objectDefineProperty(callback, \"stopWatchingAll\", {\r\n            configurable: true,\r\n            writable: true,\r\n            value() {\r\n                callback[WATCHER_IDENTIFIER].watching.forEach(watcherList =>\r\n                    watcherList.delete(callback)\r\n                );\r\n                callback[WATCHER_IDENTIFIER].watching.clear();\r\n            }\r\n        });\r\n    }\r\n\r\n    callback[WATCHER_IDENTIFIER].watching.add(watchersSet);\r\n}\r\n\r\n/**\r\n * Removes the reference to the given Set instance from the callback function provided\r\n * @private\r\n * @param {Function} callback\r\n * @param {Set} watchersSet\r\n */\r\nfunction unsetCallbackAsWatcherOf(callback, watchersSet) {\r\n    if (callback[WATCHER_IDENTIFIER]) {\r\n        callback[WATCHER_IDENTIFIER].watching.delete(watchersSet);\r\n    }\r\n}\r\n\r\n\r\nexport function makeArrayWatchable(arr) {\r\n    if (!arr[OBSERVABLE_IDENTIFIER]) {\r\n        setupObjState(arr);\r\n    }\r\n\r\n    // If array already has a watchable prototype, then exit\r\n    if (arr[HAS_ARRAY_WATCHABLE_PROTO]) {\r\n        return;\r\n    }\r\n\r\n    const arrCurrentProto = arr.__proto__; // eslint-disable-line\r\n\r\n    // Create prototype interceptors?\r\n    if (!arrCurrentProto[ARRAY_WATCHABLE_PROTO]) {\r\n        const arrProtoInterceptor = Object.create(arrCurrentProto);\r\n        ARRAY_MUTATING_METHODS.forEach(method => {\r\n            objectDefineProperty(arrProtoInterceptor, method, {\r\n                configurable: true,\r\n                writable: true,\r\n                value: function arrayMethodInterceptor(...args) {\r\n                    // FIXME: need to call `makeObservable` on any value that was inserted, if `deep` is true\r\n                    const response = arrCurrentProto[method].call(this, ...args);\r\n                    this[OBSERVABLE_IDENTIFIER].dependents.notify();\r\n                    this[OBSERVABLE_IDENTIFIER].watchers.notify();\r\n                    return response;\r\n                }\r\n            });\r\n        });\r\n\r\n        // VALUE ADD: include a `size` read only attribute\r\n        objectDefineProperty(arrProtoInterceptor, \"size\", {\r\n            configurable: true,\r\n            get() {\r\n                if (TRACKERS.size) {\r\n                    TRACKERS.forEach(\r\n                        this[OBSERVABLE_IDENTIFIER].storeCallback,\r\n                        this[OBSERVABLE_IDENTIFIER]\r\n                    );\r\n                }\r\n                return this.length;\r\n            }\r\n        });\r\n\r\n        // Add flag to new array interceptor prototype indicating its watchable\r\n        objectDefineProperty(arrProtoInterceptor, HAS_ARRAY_WATCHABLE_PROTO, {\r\n            value: true\r\n        });\r\n\r\n        // Store the new interceptor prototype on the real prototype\r\n        objectDefineProperty(arrCurrentProto, ARRAY_WATCHABLE_PROTO, {\r\n            configurable: true,\r\n            writable: true,\r\n            value: arrProtoInterceptor\r\n        });\r\n    }\r\n\r\n    arr.__proto__ = arrCurrentProto[ARRAY_WATCHABLE_PROTO]; // eslint-disable-line\r\n}\r\n\r\n\r\nexport default objectWatchProp;\r\n","import { GLOBAL } from \"./getGlobal\"\r\nimport { FakeIterator } from \"./Iterator\"\r\nimport {\r\n    arrayIndexOf,\r\n    arraySplice,\r\n    objectDefineProperty,\r\n    objectDefineProperties,\r\n    SymbolIterator\r\n} from \"./runtime-aliases\"\r\n\r\n//======================================================\r\n\r\nexport const Map = GLOBAL.Map && GLOBAL.Map.prototype[SymbolIterator] ? GLOBAL.Map : FakeMap;\r\nexport default Map;\r\n\r\nexport function FakeMap() {\r\n    // FIXME: support for iterable input param\r\n}\r\n\r\nobjectDefineProperties(FakeMap.prototype, {\r\n    constructor: { value: FakeMap, configurable: true },\r\n    _: {\r\n        get() {\r\n            objectDefineProperty(this, \"_\", { value: {\r\n                keys: [],\r\n                values: []\r\n            } });\r\n            return this._;\r\n        }\r\n    },\r\n    get: {\r\n        value(key) {\r\n            return this._.values[arrayIndexOf(this._.keys, key)];\r\n        }\r\n    },\r\n    set: {\r\n        value(key, value) {\r\n            if (arrayIndexOf(this._.keys, key) === -1) {\r\n                this._.keys.push(key);\r\n                this._.values.push(value);\r\n            }\r\n            return this;\r\n        }\r\n    },\r\n    has: {\r\n        value(key) { return arrayIndexOf(this._.keys, key) !== -1; }\r\n    },\r\n    size: {\r\n        get() { return this._.keys.length; }\r\n    },\r\n    clear: {\r\n        value() {\r\n            arraySplice(this._.keys, 0);\r\n            arraySplice(this._.values, 0);\r\n        }\r\n    },\r\n    delete: {\r\n        value(key) {\r\n            const idx = arrayIndexOf(this._.keys, key);\r\n            if (idx !== -1) {\r\n                arraySplice(this._.keys, idx, 1);\r\n                arraySplice(this._.values, idx, 1);\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    keys: {\r\n        value() {\r\n            return new FakeIterator(this._.keys);\r\n        }\r\n    },\r\n    values: {\r\n        value() {\r\n            return new FakeIterator(this._.values);\r\n        }\r\n    },\r\n    entries: {\r\n        value() {\r\n            return new FakeIterator(this._.keys, this._.values);\r\n        }\r\n    },\r\n    forEach: {\r\n        value(cb, thisArg) {\r\n            this._.keys.forEach((item, i) => cb(this._.values[i], item, this), thisArg);\r\n        }\r\n    },\r\n    [SymbolIterator]: {\r\n        value() {\r\n            return this.entries();\r\n        }\r\n    }\r\n});\r\n\r\n","import dataStore    from \"@purtuga/common/src/jsutils/dataStore\"\r\nimport Map          from \"@purtuga/common/src/jsutils/es6-Map\"\r\n\r\n//=====================================================\r\nconst DOCUMENT              = document;\r\nconst FUNCTION              = Function;\r\nconst ELEMENT_PROTOTYPE     = Element.prototype;\r\nconst ARRAY_PROTOTYPE       = Array.prototype;\r\nconst VALUE_GETTERS         = new Map();\r\nconst _bind                 = FUNCTION.bind.call.bind(FUNCTION.bind);\r\n\r\nexport const DOM_DATA_BIND_PROP = \"DomDataBind\";\r\nexport const PRIVATE            = dataStore.create();\r\nexport const UUID               = `D-${ Date.now() }-${ Math.random().toString(36).replace(/[^a-z0-9]+/g, '') }`;\r\nexport const escapeString       = str => String(str).replace(/[-[\\]/{}()*+?.\\\\^$|]/g, \"\\\\$&\");\r\nexport const bindCallTo         = _bind(FUNCTION.call.bind, FUNCTION.call);\r\nexport const isPureObject       = o => Object.prototype.toString.call(o) === \"[object Object]\";\r\nexport const isString           = s => \"string\" === typeof s;\r\nexport const arrayForEach       = bindCallTo(ARRAY_PROTOTYPE.forEach);\r\nexport const arraySlice         = bindCallTo(ARRAY_PROTOTYPE.slice);\r\nexport const hasAttribute       = bindCallTo(ELEMENT_PROTOTYPE.hasAttribute);\r\nexport const getAttribute       = bindCallTo(ELEMENT_PROTOTYPE.getAttribute);\r\nexport const setAttribute       = bindCallTo(ELEMENT_PROTOTYPE.setAttribute);\r\nexport const removeAttribute    = bindCallTo(ELEMENT_PROTOTYPE.removeAttribute);\r\nexport const insertBefore       = bindCallTo(ELEMENT_PROTOTYPE.insertBefore);\r\nexport const removeChild        = bindCallTo(ELEMENT_PROTOTYPE.removeChild);\r\nexport const createComment      = _bind(DOCUMENT.createComment, DOCUMENT);\r\nexport const createTextNode     = _bind(DOCUMENT.createTextNode, DOCUMENT);\r\nexport const createDocFragment  = _bind(DOCUMENT.createDocumentFragment, DOCUMENT);\r\nexport const logError           = _bind(console.error, console); // eslint-disable-line\r\n\r\n\r\nexport function createValueGetter(evalCode) {\r\n    evalCode = evalCode.trim();\r\n\r\n    if (VALUE_GETTERS.has(evalCode)) {\r\n        return VALUE_GETTERS.get(evalCode);\r\n    }\r\n\r\n    const fn = new FUNCTION(\"$data\", `\r\nwith ($data) {\r\n    if ($data) {\r\n        with ($data) {\r\n            return ${ evalCode };\r\n        }\r\n    } \r\n    else {\r\n        return ${ evalCode };\r\n    }\r\n}\r\n`);\r\n    VALUE_GETTERS.set(evalCode, fn);\r\n    return fn;\r\n}\r\n\r\nexport function getNodeAttrNames(node){\r\n    const attrNames = [];\r\n    const total = node.attributes.length;\r\n\r\n    for(let i = 0; i < total; i++) {\r\n        attrNames.push(node.attributes.item(i).name);\r\n    }\r\n\r\n    return attrNames;\r\n}","/**\r\n * Finds Elements within a given HTML Element using `querySelectorAll` and\r\n * return an Array with those elements.\r\n *\r\n * @function domFind\r\n *\r\n * @param {HTMLElement} domEle\r\n * @param {String} selector\r\n *\r\n * @returns {Array<HTMLElement>}\r\n */\r\nexport function domFind(domEle, selector){\r\n    return Array.prototype.slice.call(domEle.querySelectorAll(selector));\r\n}\r\nexport default domFind;\r\n","import nextTick from \"@purtuga/common/src/jsutils/nextTick\"\r\nimport Compose from \"@purtuga/common/src/jsutils/Compose\"\r\nimport {logError, PRIVATE, removeAttribute} from \"../utils\"\r\nimport {setDependencyTracker, unsetDependencyTracker} from \"@purtuga/observables/src/objectWatchProp\"\r\n\r\n//===================================================================================\r\n\r\n/**\r\n * A DOM element directive.\r\n * NOte that any directive that removes the original DOM element from its parent\r\n * will prevent all subsequent directives from running.\r\n *\r\n * @class Directive\r\n * @extends Compose\r\n *\r\n * @param {String} directiveAttr\r\n *  The directive html element attribute as found in the element.\r\n * @param {String} attrValue\r\n *  The value of the attribute\r\n */\r\nexport class Directive extends Compose {\r\n    /**\r\n     * Checks a given element has an element attribute that matches the Directive.\r\n     * If a match is found, the html Element's attribute that was matched must be\r\n     * returned.\r\n     *\r\n     * @param {HTMLElement} ele\r\n     *\r\n     * @returns {String}\r\n     */\r\n    static has(/*ele*/) { return \"\"; }\r\n\r\n    /**\r\n     * A boolean indicating whether this directive manages the element. If set to true, then\r\n     * `DomDataBind` will not process any other directives after this one.\r\n     */\r\n    static manages() { return false; }\r\n\r\n    /**\r\n     * Render the Directive with given data\r\n     *\r\n     * @param {NodeHandler} handler\r\n     * @param {Node} node\r\n     * @param {Object} data\r\n     */\r\n    render(handler, node, data) {\r\n        let state = PRIVATE.get(handler);\r\n\r\n        if (!state) {\r\n            state = {\r\n                data:       null,\r\n                value:      \"\",\r\n                isQueued:   false,\r\n                deferUpd:   this.update.bind(this, handler),\r\n                tracker:    () => this.render(handler, node, state.data)\r\n                //update: () => {} --- should be defined by Directive subclass\r\n            };\r\n            PRIVATE.set(handler, state);\r\n\r\n        }\r\n\r\n        if (state.data !== data) {\r\n            if (state.tracker.stopWatchingAll) {\r\n                state.tracker.stopWatchingAll();\r\n            }\r\n            state.data = data;\r\n        }\r\n\r\n        if (state.isQueued) {\r\n            return;\r\n        }\r\n\r\n        state.isQueued = true;\r\n        nextTick(state.deferUpd);\r\n    }\r\n\r\n    /**\r\n     * Updates a node by generating a new value for the Directive, storing it\r\n     * in the handler `state.value` and calling `handle.update` after it.\r\n     *\r\n     * @param {NodeHandler} handler\r\n     */\r\n    update(handler) {\r\n        // destruction happens 1ms after .destroy() (Componse#destroy()) is called,\r\n        // so its possible that a handler might come in here having its `.isDestroyed`\r\n        // flag set.\r\n        if (handler.isDestroyed) {\r\n            return;\r\n        }\r\n\r\n        const handlerState = PRIVATE.get(handler);\r\n\r\n        if (handlerState) {\r\n            let newValue = \"\";\r\n\r\n            setDependencyTracker(handlerState.tracker);\r\n\r\n            try {\r\n                newValue = this._tokenValueGetter(handlerState.data || {});\r\n\r\n                // Update node\r\n                if (handler.update) {\r\n                    handler.update(newValue);\r\n                }\r\n            }\r\n            catch(e) {\r\n                logError(e);\r\n            }\r\n\r\n            unsetDependencyTracker(handlerState.tracker);\r\n\r\n            handlerState.isQueued = false;\r\n            if (handlerState.value !== newValue) {\r\n                handlerState.value = newValue;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an object with a `render` function for the given node.\r\n     *\r\n     * @param {Node} node\r\n     * @param {Array<Directive>} [directives]\r\n     *\r\n     * @return {NodeHandler}\r\n     */\r\n    getNodeHandler(node/*, directives*/) {\r\n        if (this._attr && node.nodeType !== 8 /* no comment nodes */) {\r\n            removeAttribute(node, this._attr);\r\n        }\r\n        return new NodeHandler(this, node);\r\n    }\r\n}\r\nexport default Directive;\r\n\r\n/**\r\n * A node directive handler.\r\n *\r\n * @extends Compose\r\n */\r\nclass NodeHandler extends Compose {\r\n    init(directive, node) {\r\n        this._d = directive;\r\n        this._n = node;\r\n    }\r\n\r\n    // Override destroy (which is by default \"async\" and ensure that notifications\r\n    // are turned off immediately for this Node\r\n    destroy() {\r\n        const state = PRIVATE.get(this);\r\n        if (state){\r\n            if (state.tracker && state.tracker.stopWatchingAll) {\r\n                state.tracker.stopWatchingAll();\r\n            }\r\n            if (state.data) {\r\n                state.data = null;\r\n            }\r\n        }\r\n        super.destroy();\r\n        PRIVATE.delete(this);\r\n    }\r\n\r\n    /**\r\n     * Renders the data given on input to the Node\r\n     *\r\n     * @param data\r\n     */\r\n    render(data) {\r\n        this._d.render(this, this._n, data);\r\n    }\r\n\r\n    /**\r\n     * Applies a new value to the Node. This method will check if the handler instance state data has\r\n     * a method named `update` and if so, delegate to that method as to how the node should be updated.\r\n     *\r\n     * @param newValue\r\n     */\r\n    update(newValue) {\r\n        const state = PRIVATE.get(this);\r\n        if (state && state.update) {\r\n            return state.update(newValue);\r\n        }\r\n    }\r\n}\r\n\r\n","import Directive from \"../directives/Directive\"\r\nimport {\r\n    PRIVATE,\r\n    UUID,\r\n    createValueGetter   } from \"../utils\"\r\n\r\n//===========================================================\r\n\r\nexport class TextBinding extends Directive {\r\n    init(tokenText) {\r\n        this._tokenText = tokenText;\r\n        this._tokenValueGetter = createValueGetter(tokenText);\r\n    }\r\n\r\n    render(handler, node, data) {\r\n        super.render(handler, node, data);\r\n        const state = PRIVATE.get(handler);\r\n        if (!state.update) {\r\n            state.update = newValue => {\r\n                if (newValue !== node.nodeValue) {\r\n                    node.nodeValue = newValue;\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an object with a `render` function for the given node\r\n     *\r\n     * @param {Node} node\r\n     *\r\n     * @return\r\n     */\r\n    getNodeHandler(node) {\r\n        // Text nodes are processed in a special way in `DomDataBind.getTemplateForDomElement`, where\r\n        // free-floating textnode are replaced with HTML comments in order to not lose their place when\r\n        // converted to text and then back to dom elements. We replace those here now..\r\n        if (node.nodeType === 8 && node.nodeValue === UUID) {\r\n            const nodeToRemove = node;\r\n            // FIXME: below code should use node.ownerDocument???\r\n            node = node.parentNode.insertBefore(document.createTextNode(\"\"), nodeToRemove);\r\n            nodeToRemove.parentNode.removeChild(nodeToRemove);\r\n        }\r\n\r\n        return super.getNodeHandler(node);\r\n    }\r\n}\r\n\r\nexport default TextBinding;\r\n\r\n","import {makeObservable} from \"@purtuga/observables/src/objectWatchProp\";\r\nimport domFind from \"@purtuga/common/src/domutils/domFind\"\r\nimport {\r\n    PRIVATE,\r\n    UUID,\r\n    DOM_DATA_BIND_PROP,\r\n    bindCallTo,\r\n    removeAttribute,\r\n    getAttribute,\r\n    arrayForEach,\r\n    createComment,\r\n    createDocFragment,\r\n    createTextNode,\r\n    logError\r\n} from \"./utils\"\r\nimport TextBinding from \"./bindings/text-binding\"\r\n//=========================================================================================\r\nconst DATA_TOKEN_REG_EXP_STR    = \"{{(.*?)}}\";\r\nconst DROPS_NODES_ON_CLONE = (() => {   // FUCK YOU IE!\r\n    const frag = createDocFragment();\r\n    frag.appendChild(createTextNode(\"test\"));\r\n    frag.appendChild(createTextNode(\"\"));\r\n    return frag.cloneNode(true).childNodes.length === 1;\r\n})();\r\nconst NODE_CONTAINS_MISSES_TEXT_NODES = (() => {    // FUCK YOU IE!\r\n    const div = document.createElement(\"div\");\r\n    const text = createTextNode(\"test\");\r\n    div.appendChild(text);\r\n    return !div.contains(text);\r\n})();\r\n\r\n\r\n// Local aliases\r\nconst nodeSplitText         = bindCallTo(Text.prototype.splitText);\r\n\r\n// short helpers\r\nconst reHasDataToken        = new RegExp(DATA_TOKEN_REG_EXP_STR);\r\nconst reTokenMatch          = new RegExp(DATA_TOKEN_REG_EXP_STR, \"g\");\r\nconst getNodeValue          = node => node ? node.nodeValue : \"\";\r\nconst hasToken              = node => reHasDataToken.test(getNodeValue(node));\r\n\r\n\r\n/**\r\n * A Dom template along with its set of know directives (after parsing it)\r\n */\r\nexport class Template {\r\n    constructor(html, directives = []) {\r\n        this._template = document.createElement(\"template\");\r\n        this._template.innerHTML = html;\r\n        this._directives = directives;\r\n        this._bindings = getBindingFor(this._template.content, directives);\r\n    }\r\n\r\n    /**\r\n     * Creates new DOM Element based on this template, initilizes directives\r\n     * and then applies the data to it.\r\n     *\r\n     * @param {Object} [data]\r\n     *\r\n     * @return {DocumentFragment}\r\n     *  Document Fragment returned will have a property named 'DomDataBind', which is\r\n     *  a TemplateInstance class instance\r\n     */\r\n    cloneWith(data = {}) {\r\n        makeObservable(data);\r\n        const response = document.importNode(this._template.content, true);\r\n        response[DOM_DATA_BIND_PROP] = new TemplateInstance(\r\n            response,\r\n            applyBindingsToTemplateInstance(response, this._bindings, this._directives)\r\n        );\r\n        response[DOM_DATA_BIND_PROP].setData(data);\r\n        return response;\r\n    }\r\n}\r\nexport default Template;\r\n\r\n/**\r\n * Returns a Map() that includes the paths to nodes in the Dom template that\r\n * are using Directives or have bindings.\r\n * The map \"key\" is an array of `childNodes` paths from the root of the template\r\n * all the way to the node.\r\n * The map \"value\" is an array Directive instances for that node\r\n *\r\n * @return {Map}\r\n */\r\nexport function getBindingFor(ele, directives) {\r\n    // FIXME: refactor this entire function to be faster and more efficient\r\n\r\n\r\n    // template bindings Map() structure:\r\n    //\r\n    //      bindings = Map(\r\n    //          [path, via, childNodes, to, element]: [ directive instances ],\r\n    //          // example:\r\n    //          [0,1,3]: [ directiveInstance1, directiveInstance2 ]\r\n    //      )\r\n    //  }\r\n    //\r\n\r\n    // The goal is to be able to provide a path to each elements for which a group of directives will be applied.\r\n    const bindings          = new Map(); // FIXME: these can be global and reusable - since we only ever have one call in flight to this function\r\n    const eleToBindings     = new Map();\r\n    const ignoredChildren   = new Set();\r\n    let domEle;\r\n\r\n    const directiveIterator = Directive => {\r\n        let attrName;\r\n        let attrValue;\r\n        let managesNode;\r\n        let elePlaceholder = domEle;\r\n\r\n        while ((attrName = Directive.has(domEle))) {\r\n            attrValue = getAttribute(domEle, attrName);\r\n            managesNode = Directive.manages();\r\n\r\n            if (managesNode) {\r\n                elePlaceholder = createComment(\"\");\r\n            }\r\n\r\n            getArrayForNodeFromMap(eleToBindings, elePlaceholder).push(\r\n                getDirectiveForAttribute(Directive, attrName, attrValue)\r\n            );\r\n\r\n            removeAttribute(domEle, attrName);\r\n\r\n            if (managesNode) {\r\n                ignoredChildren.add(domEle);\r\n\r\n                // Replace this node with a Comment, and store the node's html\r\n                // as the comment data, which is then used by the directive instance\r\n                // to `render()` it to DOM when applicable\r\n                domEle.parentNode.insertBefore(elePlaceholder, domEle);\r\n                const fakeEle = document.createElement(\"div\");\r\n                fakeEle.appendChild(domEle);\r\n                elePlaceholder.data = fakeEle.innerHTML;\r\n            }\r\n        }\r\n        return managesNode;\r\n    };\r\n\r\n    const processTextNode = child => {\r\n        if (hasToken(child)) {\r\n            reTokenMatch.lastIndex = 0;\r\n            let nodeValue = getNodeValue(child);\r\n            let childTokenMatches = reTokenMatch.exec(nodeValue);\r\n\r\n            while (childTokenMatches) {\r\n                // If no need to split the text node, then just create a binding for it and exit\r\n                if (nodeValue === \"{{\" + childTokenMatches[1] + \"}}\") {\r\n                    getArrayForNodeFromMap(eleToBindings, child).push(getTextBindingForToken(TextBinding, childTokenMatches[1]));\r\n                    childTokenMatches = null;\r\n                }\r\n                else {\r\n                    let tokenTextNode = nodeSplitText(child, childTokenMatches.index);\r\n\r\n                    // IF browser drops empty nodes, then fix the child node (which now is the left portion\r\n                    // of the split)\r\n                    if (DROPS_NODES_ON_CLONE) {\r\n                        fixEmptyTextNode(child);\r\n                    }\r\n\r\n                    // FIXME: need to handle empty node when browser does not do clones correctly (IE for sure... Edge might be fixed now)\r\n\r\n                    // Split again at the end of token, so that we have a dedicated text node for the token value.\r\n                    // Because this will be used as a template, also need to replace this token value node\r\n                    // with an HTML comment, which will be replaced later during directive initialization\r\n                    // The remainder of the Text value is assigned back to `child` so that we can continue\r\n                    // to check it for other text tokens.\r\n                    child = nodeSplitText(tokenTextNode, childTokenMatches[0].length);\r\n                    const tokenPlaceholder = tokenTextNode.parentNode.insertBefore(createComment(UUID), tokenTextNode);\r\n                    tokenTextNode.parentNode.removeChild(tokenTextNode);\r\n\r\n                    getArrayForNodeFromMap(eleToBindings, tokenPlaceholder).push(getTextBindingForToken(TextBinding, childTokenMatches[1]));\r\n\r\n                    // Reset the regular expression (since `child` was also \"reset\") and execute\r\n                    // the regular expression again on the remaining text\r\n                    reTokenMatch.lastIndex = 0;\r\n                    childTokenMatches = reTokenMatch.exec(getNodeValue(child));\r\n\r\n                    if (!childTokenMatches && DROPS_NODES_ON_CLONE) {\r\n                        fixEmptyTextNode(child);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    findAllNodes(ele).forEach(node => {\r\n        let skip = false;\r\n\r\n        if (ignoredChildren.size) {\r\n            for (let ignoredParent of ignoredChildren.values()) {\r\n                if (NODE_CONTAINS_MISSES_TEXT_NODES && node.nodeType === 3) {\r\n                    if (ignoredParent.compareDocumentPosition(node) & 16) {\r\n                        skip = true;\r\n                    }\r\n                }\r\n                else if (ignoredParent.contains(node)) {\r\n                    skip = true;\r\n                }\r\n\r\n                if (skip) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        domEle = node;\r\n\r\n        if (!skip) {\r\n            // Process Element level Directives\r\n            if (node.nodeType === 1) {\r\n                directives.some(directiveIterator);\r\n            }\r\n            // TEXT nodes\r\n            else if (node.nodeType === 3) {\r\n                processTextNode(node);\r\n            }\r\n        }\r\n    });\r\n\r\n    domEle = null;\r\n\r\n\r\n    // Create the list array of node indexes for each binding processed\r\n    eleToBindings.forEach((directiveBindings, bindingEle) => {\r\n        if (ele === bindingEle) {\r\n            bindings.set([], directiveBindings);\r\n            return;\r\n        }\r\n\r\n        const path  = [];\r\n        let walkEle = bindingEle;\r\n        let parent  = walkEle.parentNode;\r\n\r\n        while (walkEle !== ele) {\r\n            path.unshift(path.indexOf.call(parent.childNodes, walkEle));\r\n            walkEle = walkEle.parentNode;\r\n            parent  = walkEle.parentNode;\r\n        }\r\n\r\n        bindings.set(path, directiveBindings);\r\n    });\r\n\r\n    eleToBindings.clear();\r\n    ignoredChildren.clear();\r\n\r\n    return bindings;\r\n}\r\n\r\n/**\r\n * Applies the bindings in the given Map to the DocumentFragment provided on input.\r\n *\r\n * @param {DocumentFragment} frag\r\n * @param {Map<Array<Number>, Array<Directive>>} bindings\r\n * @param {Array<Directive>} Directives\r\n *\r\n * @return {Array<NodeHandler>}\r\n *  An array of Node directive handlers is returned.\r\n */\r\nexport function applyBindingsToTemplateInstance(frag, bindings, Directives) {\r\n    const response = [];\r\n\r\n    bindings.forEach((directivesInstances, path) => {\r\n        const node = getNodeAt(frag, path);\r\n        if (!node) {\r\n            logError(new Error(`dom-data-bind#render(): Unable to find node!`));\r\n            return;\r\n        }\r\n\r\n        for (let i=0, t=directivesInstances.length; i < t; i++) {\r\n            response.push(directivesInstances[i].getNodeHandler(node, Directives));\r\n        }\r\n    });\r\n\r\n    return response;\r\n}\r\n\r\nfunction getNodeAt(root, path) {\r\n    if (!path.length) {\r\n        return root;\r\n    }\r\n\r\n    arrayForEach(path, index => root = root.childNodes[index]);\r\n    return root;\r\n}\r\n\r\nfunction getArrayForNodeFromMap(map, node) {\r\n    if (!map.has(node)) {\r\n        map.set(node, []);\r\n    }\r\n    return map.get(node);\r\n}\r\n\r\n/**\r\n * Returns a node handlers for the given directive\r\n *\r\n * @param {Directive} Directive\r\n * @param {String} tokenText\r\n *  The token text (no curly braces)\r\n *\r\n * @returns {Directive}\r\n *  Returns a Directive instance. Call `.getNodeHandler` to get a handler for a given node\r\n */\r\nfunction getTextBindingForToken(Directive, tokenText) {\r\n    tokenText = tokenText.trim();\r\n\r\n    let directiveInstances = PRIVATE.get(Directive);\r\n\r\n    if (!directiveInstances) {\r\n        directiveInstances = {};\r\n        PRIVATE.set(Directive, directiveInstances);\r\n    }\r\n\r\n    if (!directiveInstances[tokenText]) {\r\n        directiveInstances[tokenText] = new Directive(tokenText);\r\n    }\r\n\r\n    return directiveInstances[tokenText];\r\n}\r\n\r\nfunction getDirectiveForAttribute (Directive, attrName, attrValue) {\r\n    attrValue = attrValue.trim();\r\n\r\n    const directiveSignature    = `${attrName}-${ UUID }-${ attrValue }`;\r\n    let directiveInstances      = PRIVATE.get(Directive);\r\n\r\n    if (!directiveInstances) {\r\n        directiveInstances = {};\r\n        PRIVATE.set(Directive, directiveInstances);\r\n    }\r\n\r\n    if (!directiveInstances[directiveSignature]) {\r\n        directiveInstances[directiveSignature] = new Directive(attrName, attrValue);\r\n    }\r\n\r\n    return directiveInstances[directiveSignature];\r\n}\r\n\r\n/**\r\n *\r\n * @private\r\n * @param {HTMLElement} ele\r\n * @returns {boolean}\r\n */\r\nfunction onlyElementsWithAttributes(ele/*, index, arr*/) {\r\n    return ele.nodeType !== 1 || (ele.nodeType === 1 && ele.attributes.length > 0);\r\n}\r\n\r\n/**\r\n *\r\n * @private\r\n * @param {Array} resultArr\r\n * @param {HTMLElement} ele\r\n * @returns {Array}\r\n */\r\nfunction addTextNodes(resultArr, ele /*, index, arr*/) {\r\n    resultArr.push(ele);\r\n    if (ele.hasChildNodes()) {\r\n        ele = ele.firstChild;\r\n        for (;ele;) {\r\n            const nextSibling = ele.nextSibling;\r\n\r\n            // IF Text node and it has the token\r\n            if (ele.nodeType === 3 && !!ele.nodeValue && reHasDataToken.test(getNodeValue(ele))) {\r\n                resultArr.push(ele);\r\n            }\r\n\r\n            if (DROPS_NODES_ON_CLONE) {\r\n                fixEmptyTextNode(ele);\r\n            }\r\n\r\n            ele = nextSibling;\r\n        }\r\n    }\r\n    return resultArr;\r\n}\r\n\r\nfunction fixEmptyTextNode(node) {\r\n    if (node.nodeType === 3 && DROPS_NODES_ON_CLONE && !node.nodeValue) {\r\n        node.parentNode.insertBefore(createComment(\"\"), node);\r\n        node.parentNode.removeChild(node);\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @private\r\n * @param {HTMLElement} ele\r\n *\r\n * @return {Array<Node>}\r\n */\r\nfunction findAllNodes(ele) {\r\n    return [ele]\r\n        .concat(domFind(ele, \"*\"))\r\n        .reduce(addTextNodes, [])\r\n        .filter(onlyElementsWithAttributes);\r\n}\r\n\r\n\r\nclass TemplateInstance {\r\n    constructor(docFrag, bindings) {\r\n        this._frag = docFrag;\r\n        this._bindings = bindings;\r\n    }\r\n\r\n    destroy() {\r\n        if (this._bindings) {\r\n            for (let i = 0, t = this._bindings.length; i < t; i++) {\r\n                this._bindings[i].destroy();\r\n            }\r\n            this._bindings.length = 0;\r\n        }\r\n    }\r\n\r\n    setData(data) {\r\n        for (let i = 0, t = this._bindings.length; i < t; i++) {\r\n            this._bindings[i].render(data);\r\n        }\r\n    }\r\n}\r\n\r\n","import Template from \"./Template\"\r\n\r\n//==========================================================================\r\nconst TEMPLATES = new Map();\r\n\r\n/**\r\n * Returns a DocumentFragment representation of the given `html` code provided on\r\n * input bound to the given data.\r\n *\r\n * @param {String} html\r\n * @param {Object} [data]\r\n * @param {Array} [directives]\r\n *\r\n * @return {DocumentFragment}\r\n */\r\nexport function render(html, data, directives) {\r\n    if (!TEMPLATES.has(html)) {\r\n        TEMPLATES.set(html, new Template(html, directives));\r\n    }\r\n    return TEMPLATES.get(html).cloneWith(data);\r\n}\r\nexport default render;\r\n","import Compose from \"@purtuga/common/src/jsutils/Compose\"\r\nimport {makeObservable} from \"@purtuga/observables/src/objectWatchProp\";\r\nimport { PRIVATE, arrayForEach, isString } from \"./utils\"\r\nimport { getBindingFor, applyBindingsToTemplateInstance } from \"./Template\"\r\nimport { render } from \"./render\";\r\n\r\n//======================================================================\r\n\r\n/**\r\n * Bind data to a DOM element and automatically persist changes in that data to the UI.\r\n * By default, this constructor provides interpolation of Text tokens found in the DOM\r\n * structure (represented with double curly braces: `{{ }}`). Directives can be used\r\n * by extending this constructor and adding them to the [directives]{@link DomDataBind.directives}\r\n * static property.\r\n *\r\n * @class DomDataBind\r\n * @extends Compose\r\n *\r\n * @param {String |HTMLElement} html\r\n *  The HTML element that will be parse and to which `data` will be bound.\r\n *\r\n * @param {Object} data\r\n *  An object whose data will be used to bind to `html` element (once crated) .\r\n *\r\n */\r\nexport const DomDataBind = Compose.extend({\r\n    /**\r\n     * The Element whose data was bound to.\r\n     * When a string is used on input, this will be a DocumentFragment, which\r\n     * means that it could be empty if its content was inserted into DOM\r\n     */\r\n    $ele: null,\r\n\r\n    init(html, data) {\r\n        const Factory = this.getFactory();\r\n        const state = {\r\n            html,\r\n            data,\r\n            directives: Factory.directives.slice(0)\r\n        };\r\n\r\n        PRIVATE.set(this, state);\r\n\r\n        if (isString(html)) {\r\n            this.$ele = render(html, data, state.directives);\r\n            state.bindings = this.$ele._domDataBindNodeHandlers;\r\n        } else {\r\n            this.$ele = html;\r\n            state.bindings = applyBindingsToTemplateInstance(html, getBindingFor(html, state.directives), state.directives);\r\n            if (data) {\r\n                this.setData(data);\r\n            }\r\n        }\r\n\r\n        this.onDestroy(() => {\r\n            arrayForEach(state.bindings, binding => binding.destroy());\r\n\r\n            delete state.data;\r\n            delete state.directives;\r\n            delete state.bindings;\r\n\r\n            Factory.getDestroyCallback(state, PRIVATE)();\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Set data on to the DOM provided during initialization.\r\n     * In most cases, you should never have the need to call this method. Data\r\n     * provided during initialization is \"live\" and changes are automatically\r\n     * reflected to dom.\r\n     */\r\n    setData(data) {\r\n        makeObservable(data);\r\n        const bindings = PRIVATE.get(this).bindings;\r\n        arrayForEach(bindings, binding => binding.render(data));\r\n    }\r\n});\r\nexport default DomDataBind;\r\n\r\n/**\r\n * A list of Directives to be used.\r\n *\r\n * @name DomDataBind.directives\r\n * @type {Array}\r\n */\r\nDomDataBind.directives = [];\r\n","/**\r\n * Check if an element has a given class\r\n *\r\n * @function domHasClass\r\n *\r\n * @param {HTMLElement} el\r\n * @param {String} cssClass\r\n *\r\n * @return {Boolean}\r\n */\r\nexport function domHasClass(el, cssClass){\r\n    if (el && cssClass) {\r\n        return el.classList.contains(cssClass);\r\n    }\r\n    return false;\r\n}\r\nexport default domHasClass;\r\n","/**\r\n * Adds class to an element\r\n *\r\n * @function domAddClass\r\n *\r\n * @param {HTMLElement} el\r\n * @param {String} cssClass\r\n *  Multiple classes can be set using spaces as a delimiter\r\n */\r\nexport function domAddClass(el, cssClass){\r\n    let classNameList = String(cssClass).trim().split(/\\s+/).map(className => className.trim());\r\n    if (el && classNameList.length) {\r\n        classNameList.forEach((cssClass) => el.classList.add(cssClass));\r\n    }\r\n}\r\nexport default domAddClass;","/**\r\n * removes a class from an element\r\n *\r\n * @function domRemoveClass\r\n *\r\n * @param {HTMLElement} el\r\n * @param {String} cssClass\r\n */\r\nexport function domRemoveClass(el, cssClass){\r\n    return el.classList.remove(cssClass);\r\n}\r\nexport default domRemoveClass;","import domHasClass      from \"@purtuga/common/src/domutils/domHasClass\"\r\nimport domAddClass      from \"@purtuga/common/src/domutils/domAddClass\"\r\nimport domRemoveClass   from \"@purtuga/common/src/domutils/domRemoveClass\"\r\nimport Directive        from \"./Directive\"\r\nimport {\r\n    PRIVATE,\r\n    createValueGetter,\r\n    hasAttribute  } from \"../utils\"\r\n\r\n//============================================\r\nconst DIRECTIVE = \"_class\";\r\n\r\nexport class ClassDirective extends Directive {\r\n    static has(ele) {\r\n        return hasAttribute(ele, DIRECTIVE) ? DIRECTIVE : \"\";\r\n    }\r\n\r\n\r\n    init(attr, attrValue) {\r\n        this._attr              = attr;\r\n        this._tokenValueGetter  = createValueGetter((attrValue || \"\"));\r\n    }\r\n\r\n    render(handler, node, data) {\r\n        super.render(handler, node, data);\r\n        const state = PRIVATE.get(handler);\r\n        if (!state.update) {\r\n            state.update = newValue => applyCssClassesToNode(node, newValue, newValue !== state.value ? state.value : {});\r\n        }\r\n    }\r\n}\r\n\r\nexport default ClassDirective;\r\n\r\n\r\nfunction applyCssClassesToNode(node, newClasses = {}, oldClasses = {}) {\r\n    Object.keys(newClasses)\r\n        .concat(Object.keys(oldClasses))\r\n        .forEach(className => {\r\n            if (newClasses[className] && !domHasClass(node, className)) {\r\n                domAddClass(node, className);\r\n            }\r\n            else if (!newClasses[className] && domHasClass(node, className)) {\r\n                domRemoveClass(node, className);\r\n            }\r\n        });\r\n}\r\n","import {\r\n    PRIVATE,\r\n    createValueGetter,\r\n    hasAttribute    }   from \"../utils\"\r\nimport Directive        from \"./Directive\"\r\n\r\n//============================================\r\nconst DIRECTIVE = \"_style\";\r\n\r\nexport class StyleDirective extends Directive {\r\n    static has(ele) {\r\n        return hasAttribute(ele, DIRECTIVE) ? DIRECTIVE : \"\";\r\n    }\r\n\r\n\r\n    init(attr, attrValue) {\r\n        this._attr              = attr;\r\n        this._tokenValueGetter  = createValueGetter((attrValue || \"\"));\r\n    }\r\n\r\n    render(handler, node, data) {\r\n        super.render(handler, node, data);\r\n        const state = PRIVATE.get(handler);\r\n        if (!state.update) {\r\n            const eleStyleList  = node.style;\r\n            state.update        = newValue => {\r\n                Object.keys(newValue).forEach(styleProp => {\r\n                    if (eleStyleList[styleProp] !== newValue[styleProp]) {\r\n                        eleStyleList[styleProp] = newValue[styleProp];\r\n                    }\r\n                });\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\nexport default StyleDirective;","import Directive    from \"./Directive\"\r\nimport {\r\n    PRIVATE,\r\n    DOM_DATA_BIND_PROP,\r\n    arraySlice,\r\n    hasAttribute,\r\n    createComment,\r\n    insertBefore,\r\n    removeChild,\r\n    createValueGetter } from \"../utils\"\r\nimport {render} from \"../render\"\r\n\r\n//============================================\r\nconst DIRECTIVE = \"_if\";\r\n\r\nexport class IfDirective extends Directive {\r\n    static has(ele) {\r\n        return hasAttribute(ele, DIRECTIVE) ? DIRECTIVE : \"\";\r\n    }\r\n\r\n    static manages() { return true; }\r\n\r\n    init(attr, attrValue) {\r\n        this._attr              = attr;\r\n        this._tokenValueGetter  = createValueGetter((attrValue || \"\"));\r\n    }\r\n\r\n    render(handler, node, data) {\r\n        super.render(handler, node, data);\r\n        const state = PRIVATE.get(handler);\r\n\r\n        if (!state.update) {\r\n            state.renderedEle           = null;\r\n            state.insertEle             = handler._placeholderEle;\r\n            state.directives            = handler._directives;\r\n            state.destroyRenderedEle    = destroyRenderedEle;\r\n            state.renderTemplate        = handler._n.data;\r\n            state.update                = renderUpdate;\r\n            handler.onDestroy(() => state.destroyRenderedEle());\r\n        }\r\n    }\r\n\r\n    getNodeHandler(node, directives) {\r\n        const handler = super.getNodeHandler(node);\r\n        handler._placeholderEle = createComment(\"\");\r\n        handler._directives = directives;\r\n        insertBefore(node.parentNode, handler._placeholderEle, node);\r\n        removeChild(node.parentNode, node);\r\n        return handler;\r\n    }\r\n}\r\n\r\nfunction renderUpdate(showElement) {\r\n    // this === state object\r\n    if (this.value === showElement) {\r\n        return;\r\n    }\r\n\r\n    if (showElement && !this.renderedEle) {\r\n        this.renderedEle = render(this.renderTemplate, this.data, this.directives);\r\n        this.renderedEle._children = arraySlice(this.renderedEle.childNodes, 0);\r\n        insertBefore(this.insertEle.parentNode, this.renderedEle, this.insertEle);\r\n    }\r\n    else if (!showElement && this.renderedEle)  {\r\n        this.destroyRenderedEle();\r\n    }\r\n}\r\n\r\nfunction destroyRenderedEle() {\r\n    // this === state object\r\n    if (this.renderedEle) {\r\n        this.renderedEle._children.forEach(e => e.parentNode && e.parentNode.removeChild(e));\r\n        this.renderedEle[DOM_DATA_BIND_PROP].destroy();\r\n        this.renderedEle = null;\r\n    }\r\n}\r\n\r\nexport default IfDirective;\r\n","import Directive        from \"./Directive\"\r\nimport {\r\n    PRIVATE,\r\n    createValueGetter,\r\n    hasAttribute    }   from \"../utils\"\r\n\r\n//============================================\r\nconst DIRECTIVE             = \"_show\";\r\nconst HIDDEN                = \"none\";\r\n\r\nexport class ShowDirective extends Directive {\r\n    static has(ele) {\r\n        return hasAttribute(ele, DIRECTIVE) ? DIRECTIVE : \"\";\r\n    }\r\n\r\n    init(attr, attrValue) {\r\n        this._attr              = attr;\r\n        this._tokenValueGetter  = createValueGetter((attrValue || \"\"));\r\n    }\r\n\r\n    render(handler, node, data) {\r\n        super.render(handler, node, data);\r\n        const state = PRIVATE.get(handler);\r\n        if (!state.update) {\r\n            const eleStyleList      = node.style;\r\n            const eleDisplayStyle   = node.display || \"\";\r\n            state.update            = newValue => {\r\n                if (newValue) {\r\n                    eleStyleList.display = eleDisplayStyle;\r\n                }\r\n                else if (eleStyleList.display !== HIDDEN)  {\r\n                    eleStyleList.display = HIDDEN;\r\n                }\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\nexport default ShowDirective;","import Directive                from \"./Directive\"\r\nimport {\r\n    PRIVATE,\r\n    removeAttribute,\r\n    setAttribute,\r\n    createValueGetter,\r\n    getNodeAttrNames } from \"../utils\"\r\n\r\n//============================================\r\nconst attrRegExp = /^_attr\\.(.*)/;\r\n\r\nexport class AttrDirective extends Directive {\r\n\r\n    static get _matches() { return attrRegExp; }\r\n\r\n    static get _isProp() { return false; }\r\n\r\n    static has(ele) {\r\n        let directiveAttr = \"\";\r\n        getNodeAttrNames(ele).some(attr => this._matches.test(attr) && (directiveAttr = attr));\r\n        return directiveAttr;\r\n    }\r\n\r\n\r\n    init(attr, attrValue) {\r\n        this._attr              = attr;\r\n        this._tokenValueGetter  = createValueGetter((attrValue || \"\"));\r\n        this._htmlAttr          = (new RegExp(this.constructor._matches)).exec(attr)[1];\r\n    }\r\n\r\n    render(handler, node, data) {\r\n        super.render(handler, node, data);\r\n        let state = PRIVATE.get(handler);\r\n        if (!state.update) {\r\n            state.update = newValue => {\r\n                if (this.constructor._isProp) {\r\n                    if (newValue !== state.value) {\r\n                        node[this._htmlAttr] = newValue;\r\n                    }\r\n                }\r\n                else {\r\n                    if (newValue && state.value !== newValue) {\r\n                        setAttribute(node, this._htmlAttr, newValue);\r\n                    }\r\n                    else if (state.value && !newValue) {\r\n                        removeAttribute(node, this._htmlAttr);\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\nexport default AttrDirective;\r\n","import AttrDirective from \"./attr-directive\"\r\n\r\nconst matchRegExp = /^_prop\\.(.*)/;\r\nexport class PropDirective extends AttrDirective {\r\n    static get _matches() { return matchRegExp; }\r\n    static _isProp() { return true; }\r\n}\r\nexport default PropDirective;\r\n","/**\r\n * Adds an event handler to a DOM element and returns back an\r\n * object that allows for removal of the event.\r\n *\r\n * @function domAddEventListener\r\n *\r\n * @param {HTMLElement} ele\r\n * @param {String} event\r\n *  The event to listen to (ex. `click`). Multiple events can be defined\r\n *  by separating them with whitespace\r\n * @param {Function} callback\r\n * @param {Boolean} [capture]\r\n *\r\n * @return DOMEventListener\r\n *\r\n * @example\r\n *\r\n * var listener = domAddEventHandler(myEle, \"click\", function(){});\r\n * ...\r\n * listener.remove();\r\n */\r\nexport function domAddEventListener(ele, event, callback, capture) {\r\n    let events      = event.split(/\\s+/);\r\n    let evListeners = {};\r\n\r\n    events.forEach(evName => {\r\n        ele.addEventListener(evName, callback, capture);\r\n        evListeners[evName] = {\r\n            remove: () => ele.removeEventListener(evName, callback, capture)\r\n        }\r\n    });\r\n\r\n    /**\r\n     * A DOM Event listener.\r\n     *\r\n     * @typedef {Object} DOMEventListener\r\n     *\r\n     * @property {Function} remove\r\n     * @property {Object} listeners\r\n     *  List of listeners that were bound to the DOM element. Each listeners has a\r\n     *  corresponding `.remove()` method.\r\n     */\r\n    return Object.create({\r\n        listeners: evListeners,\r\n        remove: function () {\r\n            events.forEach(evName => evListeners[evName].remove());\r\n        }\r\n    });\r\n}\r\nexport default domAddEventListener;\r\n","import domAddEventListener  from \"@purtuga/common/src/domutils/domAddEventListener\"\r\nimport Directive            from \"./Directive\"\r\nimport {\r\n    PRIVATE,\r\n    escapeString,\r\n    createValueGetter,\r\n    getNodeAttrNames,\r\n    logError } from \"../utils\"\r\n\r\n//============================================\r\nconst DIRECTIVE             = \"_on.\";\r\nconst matchesDirective      = new RegExp(`^${ escapeString(DIRECTIVE) }(.*)`);\r\n\r\nexport class OnDirective extends Directive {\r\n    static has(ele) {\r\n        let directiveAttr = \"\";\r\n        getNodeAttrNames(ele).some(attr => matchesDirective.test(attr) && (directiveAttr = attr));\r\n        return directiveAttr;\r\n    }\r\n\r\n\r\n    init(directiveAttr, attrValue) {\r\n        this._attr              = directiveAttr;\r\n        this._eventName         = (new RegExp(matchesDirective)).exec(directiveAttr)[1];\r\n        this._tokenValueGetter  = createValueGetter((attrValue || \"\"));\r\n    }\r\n\r\n    /**\r\n     * Handles the event on the node\r\n     *\r\n     * @param {NodeHandler} handler\r\n     * @param {Event} domEv\r\n     */\r\n    handleEvent(handler, domEv) {\r\n        const state = PRIVATE.get(handler);\r\n\r\n        let tokenValue;\r\n        state.data.$ev = domEv;\r\n\r\n        try {\r\n            tokenValue = this._tokenValueGetter(state.data);\r\n        }\r\n        catch(e) {\r\n            logError(e);\r\n            return;\r\n        }\r\n\r\n        delete state.data.$ev;\r\n\r\n        if (\"function\" === typeof tokenValue) {\r\n            return tokenValue.call(handler._n, domEv);\r\n        }\r\n        // DOM EventHandler interface: object having a `handleEvent` method\r\n        else if (tokenValue && \"function\" === tokenValue.handleEvent) {\r\n            tokenValue.handleEvent.call(tokenValue, domEv);\r\n        }\r\n    }\r\n\r\n    // takes care of only storing the data on the node, for when the event is triggered\r\n    render(handler, node, data) {\r\n        let state = PRIVATE.get(handler);\r\n\r\n        if (!state) {\r\n            state = {\r\n                data:       { $data: {} },\r\n                tracker:    () => this.render(handler, node, state.data)\r\n            };\r\n            PRIVATE.set(handler, state);\r\n        }\r\n\r\n        if (data) {\r\n            if (data.$data) {\r\n                state.data = data;\r\n            }\r\n            else {\r\n                state.data.$data = data;\r\n            }\r\n        }\r\n    }\r\n\r\n    getNodeHandler(node) {\r\n        const handler = super.getNodeHandler(node);\r\n        const evListener = domAddEventListener(node, this._eventName, this.handleEvent.bind(this, handler));\r\n        handler.onDestroy(() => evListener.remove());\r\n        return handler;\r\n    }\r\n}\r\n\r\nexport default OnDirective;\r\n","import { OBSERVABLE_IDENTIFIER, makeArrayWatchable } from \"./objectWatchProp\";\r\n\r\n//========================================================================\r\n\r\n/**\r\n * Watch an array for changes.  Utiltiy will override the array's mutating methods\r\n * so that notification can be provided to watchers when it changes\r\n *\r\n * @param {Array} arr\r\n * @param {Function} [callback]\r\n *  If not defined, then array is simply made \"watchable\"\r\n */\r\nexport function arrayWatch(arr, callback) {\r\n    if (!arr[OBSERVABLE_IDENTIFIER]) {\r\n        makeArrayWatchable(arr);\r\n    }\r\n\r\n    if (callback) {\r\n        arr[OBSERVABLE_IDENTIFIER].storeCallback(callback);\r\n    }\r\n\r\n    const unWatch = () => arr[OBSERVABLE_IDENTIFIER].watchers.delete(callback);\r\n    unWatch.destroy = unWatch;\r\n    return unWatch;\r\n}\r\nexport default arrayWatch;\r\n","import Map from \"@purtuga/common/src/jsutils/es6-Map\"\r\nimport {makeObservable, objectWatchProp, unsetDependencyTracker} from \"@purtuga/observables/src/objectWatchProp\"\r\nimport {arrayWatch} from \"@purtuga/observables/src/arrayWatch\"\r\nimport Directive from \"./Directive\"\r\nimport {\r\n    arrayForEach,\r\n    arraySlice,\r\n    createComment,\r\n    createDocFragment,\r\n    createValueGetter,\r\n    DOM_DATA_BIND_PROP,\r\n    getAttribute,\r\n    hasAttribute,\r\n    insertBefore,\r\n    isPureObject,\r\n    PRIVATE,\r\n    removeAttribute,\r\n    removeChild\r\n} from \"../utils\"\r\nimport {render} from \"../render\";\r\n\r\n//============================================\r\nconst DIRECTIVE     = \"_each\";\r\nconst KEY_DIRECTIVE = \"_key\";\r\nconst NOOP          = () => {};\r\nconst isEmptyList   = list => {\r\n    return (Array.isArray(list) && !list.length) || (isPureObject(list) && !Object.keys(list).length);\r\n};\r\n\r\n/**\r\n * Directive to loop through an array or object. In addition, it also support an\r\n * internal binding directive called `b:key`\r\n *\r\n * @class EachDirective\r\n * @extends Directive\r\n *\r\n * @example\r\n *\r\n * // Use with array:\r\n * _each=\"item of arrayList\"\r\n * _each=\"(item, index) of arrayList\"\r\n *\r\n * // Use with Object\r\n * _each=\"value of objectList\"\r\n * _each=\"(value, key) of objectList\"\r\n */\r\nexport class EachDirective extends Directive {\r\n    static has(ele) {\r\n        return hasAttribute(ele, DIRECTIVE) ? DIRECTIVE : \"\";\r\n    }\r\n\r\n    static manages() { return true; }\r\n\r\n\r\n    init(attr, attrValue) {\r\n        const [ iteratorArgs, listVar ] = parseDirectiveValue((attrValue || \"\").trim());\r\n        this._attr              = attr;\r\n        this._iteratorArgs      = iteratorArgs;\r\n        this._tokenValueGetter  = createValueGetter((listVar || \"\"));\r\n    }\r\n\r\n    render(handler, node, data) {\r\n        super.render(handler, node, data);\r\n        const state = PRIVATE.get(handler);\r\n\r\n        if (!state.update) {\r\n            state.binders = [];\r\n            state.bindersByKey = new Map();\r\n            state.listIterator = () => this.iterateOverList(handler, state.value);\r\n            state.isFirstRender = true;\r\n            state.usesKey = false;\r\n            state.getKey = NOOP;\r\n            state.update = newList => {\r\n                if (newList === state.value) {\r\n                    return;\r\n                }\r\n                else if (state.value) {\r\n                    state.value = null;\r\n\r\n                    if (state.listIterator.stopWatchingAll) {\r\n                        state.listIterator.stopWatchingAll();\r\n                    }\r\n                }\r\n\r\n                if (!newList) {\r\n                    this.destroyChildBinders(state.binders, handler);\r\n                    return;\r\n                }\r\n\r\n                unsetDependencyTracker(state.tracker); // We don't need to be notified of changes for individual items.\r\n                state.value = newList;\r\n\r\n                // Make sure data is observable and setup event listners on it.\r\n                makeObservable(newList);\r\n\r\n                if (Array.isArray(newList)) {\r\n                    arrayWatch(newList, state.listIterator);\r\n                }\r\n                else if (isPureObject(newList)) {\r\n                    objectWatchProp(newList, null, state.listIterator);\r\n                }\r\n\r\n                if (isEmptyList(newList) && state.binders) {\r\n                    this.destroyChildBinders(state.binders, handler);\r\n                }\r\n                else {\r\n                    this.iterateOverList(handler, newList);\r\n                }\r\n            };\r\n\r\n            // When handler is destroyed, remove data listeners\r\n            handler.onDestroy(() => {\r\n                if (state.listIterator.stopWatchingAll) {\r\n                    state.listIterator.stopWatchingAll();\r\n                }\r\n                state.bindersByKey.clear();\r\n                this.destroyChildBinders(state.binders, handler);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the binder instances and remove Elements from DOM.\r\n     *\r\n     * @param binders\r\n     * @param handler\r\n     */\r\n    destroyChildBinders(binders, handler) {\r\n        if (!binders || !binders.length) {\r\n            return;\r\n        }\r\n\r\n        binders = binders.splice(0);\r\n\r\n        if (handler._isSoleChild) {\r\n            const parentEle = handler._placeholderEle.parentNode;\r\n            parentEle.textContent = \"\";\r\n            parentEle.appendChild(handler._placeholderEle);\r\n            setTimeout(() => {\r\n                arrayForEach(binders, binder => binder._destroy());\r\n            });\r\n        }\r\n        else {\r\n            arrayForEach(binders, binder => binder._destroy());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an object (`dataObj` if provided on input) with additional keys - each\r\n     * one being the argNames that the user defined in their HTML `_each` template.\r\n     *\r\n     * It essentially matches up two array by using the keys from one array and mapping to\r\n     * values from the second array at exactly the same location.\r\n     * Example:\r\n     *\r\n     *      _each=\"item in arrayList\"\r\n     *      arrayList = [ \"value 1\" ]\r\n     *\r\n     *      // Array Keys           // Array values             // result: object\r\n     *      // Defined in the       // Data in actual           // Matches the key\r\n     *      // template             // Array                    // to the data\r\n     *      //-------------------   //-----------------         //---------------------\r\n     *      [                       [                   ===     {\r\n     *          \"item\"                  \"value 1\"       ===         item: \"value1\"\r\n     *      ]                       ]                   ===     }\r\n     *\r\n     * @param {Array} values\r\n     * @param {Object} [dataObj]\r\n     *\r\n     * @returns {Object}\r\n     */\r\n    getDataForIteration(values, dataObj) {\r\n        return this._iteratorArgs.reduce(\r\n            (rowData, argName) => {\r\n                rowData[argName] = values.shift();\r\n                return rowData;\r\n            },\r\n            dataObj || {}\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Iterates over a new set (list) and eitehr updates or builds out new elements for each item\r\n     * in that list.\r\n     *\r\n     * @param handler\r\n     * @param newData\r\n     */\r\n    iterateOverList(handler, newData) {\r\n        const state             = PRIVATE.get(handler);\r\n        const attachedEleBinder = [];\r\n        const newDomElements    = createDocFragment();\r\n        let isArray             = Array.isArray(newData);\r\n        let data;\r\n\r\n        if (isArray) {\r\n            isArray = true;\r\n            data = newData;\r\n        }\r\n        else if (isPureObject(newData)) {\r\n            data = Object.keys(newData);\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0, t = data.length; i < t; i++) {\r\n            let rowData = { $data: state.data.$data || state.data };\r\n\r\n            if (isArray) {\r\n                this.getDataForIteration([ data[i], i ], rowData);\r\n            }\r\n            else {\r\n                this.getDataForIteration([ newData[ data[i] ], data[i], i ], rowData);\r\n            }\r\n\r\n            const binder = this.getRowBinder(handler, rowData);\r\n            binder._loop.pos = i;\r\n            attachedEleBinder.push(binder);\r\n            newDomElements.appendChild(binder);\r\n        }\r\n\r\n        if (newDomElements.hasChildNodes()) {\r\n            insertBefore(handler._placeholderEle.parentNode, newDomElements, handler._placeholderEle);\r\n        }\r\n\r\n        // store the new attached set of elements in their new positions, and\r\n        // clean up old Binders that are no longer being used/displayed\r\n        // FIXME: this needs to be more efficient!!!!!!\r\n        arrayForEach(state.binders.splice(0, state.binders.length, ...attachedEleBinder), childBinder => {\r\n            if (attachedEleBinder.indexOf(childBinder) === -1) {\r\n                childBinder._destroy();\r\n            }\r\n        });\r\n\r\n        if (state.binders.length) {\r\n            this.positionChildren(\r\n                handler._placeholderEle.parentNode,\r\n                handler._placeholderEle,\r\n                state.binders\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles processing a single data item by either updating and existing binder or creating\r\n     * a new binder.\r\n     *\r\n     * @param {NodeHandler} handler\r\n     * @param {Object} rowData\r\n     *\r\n     * @returns {Template}\r\n     *  returns an array wtih two values:\r\n     *  -   the binder for the data item (could be an exising one)\r\n     *  -   Document fragment containing any new Elements that should be inserted into dom\r\n     */\r\n    getRowBinder(handler, rowData) {\r\n        const state     = PRIVATE.get(handler);\r\n        let itemBinder  = null;\r\n        let rowKey      = state.getKey(rowData);\r\n        let rowEleBinder;\r\n\r\n        if (rowKey) {\r\n            rowEleBinder = state.bindersByKey.get(rowKey);\r\n        }\r\n\r\n        // If a binder already exists for this key, then just update its data\r\n        if (rowEleBinder) {\r\n            delete rowData.$data;\r\n            rowEleBinder[DOM_DATA_BIND_PROP].setData(rowData);\r\n            itemBinder = rowEleBinder;\r\n            return itemBinder;\r\n        }\r\n\r\n        // Render a new Element from the template and store the nodes that are\r\n        // created by it (needed for later).\r\n        rowEleBinder = render(handler._n.data, rowData, handler._directives);\r\n\r\n        // Is it first render? if so, then we need to determine if the DOM element\r\n        // that was rendered has the _key attribute\r\n        if (state.isFirstRender) {\r\n            state.isFirstRender = false;\r\n\r\n            if (\r\n                rowEleBinder.childNodes.length === 1 &&\r\n                rowEleBinder.firstChild.nodeType === 1 &&\r\n                hasAttribute(rowEleBinder.firstChild, KEY_DIRECTIVE)\r\n            ) {\r\n                state.usesKey = true;\r\n                state.getKey = createValueGetter(getAttribute(rowEleBinder.firstChild, KEY_DIRECTIVE));\r\n                rowKey = state.getKey(rowData);\r\n            }\r\n        }\r\n\r\n        if (state.usesKey) {\r\n            removeAttribute(rowEleBinder.firstChild, KEY_DIRECTIVE);\r\n        }\r\n\r\n        rowEleBinder._children = arraySlice(rowEleBinder.childNodes, 0);\r\n        rowEleBinder._destroy = destroyRowElement;\r\n        rowEleBinder._state = state;\r\n        rowEleBinder._loop  = { rowEle: rowEleBinder, rowKey, pos: -1 };\r\n\r\n        if (rowKey) {\r\n            state.bindersByKey.set(rowKey, rowEleBinder);\r\n        }\r\n\r\n        itemBinder = rowEleBinder;\r\n        return itemBinder;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {HTMLElement} eleParentNode\r\n     * @param {HTMLElement} placeholderEle\r\n     * @param {Array} childEleBinders\r\n     */\r\n    positionChildren(eleParentNode, placeholderEle, childEleBinders) {\r\n        // FIXME: speed improvement = convert to while() looop\r\n        arrayForEach(childEleBinders, (childBinder, index) => {\r\n            if (childBinder._loop.pos === index) {\r\n                return;\r\n            }\r\n\r\n            insertBefore(\r\n                eleParentNode,\r\n                childBinder._loop.rowEle,\r\n                childEleBinders[index + 1] ? childEleBinders[index + 1]._loop.rowEle : placeholderEle\r\n            );\r\n            childBinder._loop.pos = index;\r\n        });\r\n    }\r\n\r\n    getNodeHandler(node, directives) {\r\n        const handler           = super.getNodeHandler(node);\r\n        handler._directives     = directives;\r\n        handler._placeholderEle = createComment(\"\");\r\n        handler._isSoleChild    = hasDedicatedParent(node);\r\n\r\n        insertBefore(node.parentNode, handler._placeholderEle, node);\r\n        removeChild(node.parentNode, node);\r\n        return handler;\r\n    }\r\n}\r\n\r\nfunction destroyRowElement () {\r\n    // this === DocumentFragment from `render()`\r\n\r\n    // remove all elements/nodes of this row from DOM\r\n    for (let i = 0, t = this._children.length; i < t; i++) {\r\n        this._children[i].parentNode && this._children[i].parentNode.removeChild(this._children[i]);\r\n    }\r\n\r\n    if (this._loop.rowKey) {\r\n        this._state.bindersByKey.delete(this._loop.rowKey);\r\n    }\r\n\r\n    this._state = null;\r\n    this[DOM_DATA_BIND_PROP].destroy();\r\n}\r\n\r\nfunction parseDirectiveValue(attrValue) {\r\n    let matches = /\\(?(.+?)\\)?\\W?(?:of|in)\\W(.*)/.exec(attrValue);\r\n    if (matches) {\r\n        matches = matches.slice(1);\r\n        matches[0] = matches[0].split(/,/).map(argName => String(argName).trim());\r\n        return matches;\r\n    }\r\n    return [];\r\n}\r\n\r\nfunction hasDedicatedParent(node) {\r\n    return Array.prototype.every.call(node.parentNode.childNodes, childNode => {\r\n        return childNode === node || (childNode.nodeType === 3 && !childNode.textContent.trim());\r\n    });\r\n}\r\n\r\n\r\nexport default EachDirective;\r\n","import Directive                from \"./Directive\"\r\nimport {\r\n    PRIVATE,\r\n    createValueGetter,\r\n    hasAttribute } from \"../utils\"\r\n\r\n//============================================\r\nconst DIRECTIVE = \"_html\";\r\n\r\nexport class HtmlDirective extends Directive {\r\n    static has(ele) {\r\n        return hasAttribute(ele, DIRECTIVE) ? DIRECTIVE : \"\";\r\n    }\r\n\r\n\r\n    init(attr, attrValue) {\r\n        this._attr              = attr;\r\n        this._tokenValueGetter  = createValueGetter((attrValue || \"\"));\r\n    }\r\n\r\n    render(handler, node, data) {\r\n        super.render(handler, node, data);\r\n        const state = PRIVATE.get(handler);\r\n        if (!state.update) {\r\n            state.update = newValue => {\r\n                if (newValue === state.value) {\r\n                    return;\r\n                }\r\n\r\n                node.innerHTML = newValue;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default HtmlDirective;\r\n\r\n","import DomDataBind      from \"./DomDataBind\"\r\nimport render           from \"./render\"\r\nimport Directive        from \"./directives/Directive\"\r\nimport ClassDirective   from \"./directives/class-directive\"\r\nimport StyleDirective   from \"./directives/style-directive\"\r\nimport IfDirective      from \"./directives/if-directive\"\r\nimport ShowDirective    from \"./directives/show-directive\"\r\nimport AttrDirective    from \"./directives/attr-directive\"\r\nimport PropDirective    from \"./directives/prop-directive\"\r\nimport OnDirective      from \"./directives/on-directive\"\r\nimport EachDirective    from \"./directives/each-directive\"\r\nimport HtmlDirective    from \"./directives/html-directive\"\r\n\r\n\r\nconst allDirectives = [\r\n    EachDirective,\r\n    IfDirective,\r\n    ClassDirective,\r\n    StyleDirective,\r\n    ShowDirective,\r\n    AttrDirective,\r\n    PropDirective,\r\n    OnDirective,\r\n    HtmlDirective\r\n];\r\n\r\nconst DomDataBindAll = DomDataBind.extend();\r\nDomDataBindAll.directives = allDirectives;\r\n\r\nexport default DomDataBindAll;\r\nexport {\r\n    DomDataBindAll,\r\n    DomDataBind,\r\n    render,\r\n    allDirectives,\r\n    Directive,\r\n    EachDirective,\r\n    IfDirective,\r\n    ClassDirective,\r\n    StyleDirective,\r\n    ShowDirective,\r\n    AttrDirective,\r\n    PropDirective,\r\n    OnDirective,\r\n    HtmlDirective\r\n};"],"sourceRoot":""}